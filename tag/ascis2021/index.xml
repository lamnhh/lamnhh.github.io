<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ascis2021 | Lam Nguyen's blog</title><link>https://lamnhh.github.io/tag/ascis2021/</link><atom:link href="https://lamnhh.github.io/tag/ascis2021/index.xml" rel="self" type="application/rss+xml"/><description>ascis2021</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Sun, 14 Nov 2021 00:00:00 +0000</lastBuildDate><image><url>https://lamnhh.github.io/media/icon_hu8b9791073e3b63e9cb38d6dd95fed664_126888_512x512_fill_lanczos_center_3.png</url><title>ascis2021</title><link>https://lamnhh.github.io/tag/ascis2021/</link></image><item><title>ASCIS 2021 Finals writeups (WIP)</title><link>https://lamnhh.github.io/post/2021-11-14-ascis2021/</link><pubDate>Sun, 14 Nov 2021 00:00:00 +0000</pubDate><guid>https://lamnhh.github.io/post/2021-11-14-ascis2021/</guid><description>&lt;p>You can download some of the binaries here: &lt;a href="https://drive.google.com/drive/folders/1q9rx2gbuZjSFzXb-_HFdaOV26zPakOAP?usp=sharing" target="_blank" rel="noopener">https://drive.google.com/drive/folders/1q9rx2gbuZjSFzXb-_HFdaOV26zPakOAP?usp=sharing&lt;/a>&lt;/p>
&lt;p>The link contains Crypto01 (buggy), Web02 (chongxun), Jeopardy Crypto01 (noise). My solutions to these challenges are also in there.&lt;/p>
&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="#crypto">Crypto&lt;/a>&lt;/p>
&lt;p>1.1. &lt;a href="#jeopardy-crypto01">Jeopardy Crypto01 (noise)&lt;/a>&lt;/p>
&lt;p>1.2. &lt;a href="#attackdefence-crypto01">Attack/Defence Crypto01&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="#web">Web&lt;/a>&lt;/p>
&lt;p>2.1. &lt;a href="#attackdefence-web02">Attack/Defence Web02&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="crypto">Crypto&lt;/h1>
&lt;h2 id="jeopardy-crypto01">Jeopardy Crypto01&lt;/h2>
&lt;pre>&lt;code class="language-python">from random import randint, getrandbits
from Crypto.Util.number import getPrime # pycryptodome
class RSA:
def __init__(self):
self.e = 65537
self.p = getPrime(512)
self.q = getPrime(512)
self.d = pow(self.e, -1, (self.p - 1) * (self.q - 1))
def encrypt(self, m: int) -&amp;gt; int:
return pow(m, self.e, self.p * self.q)
def noisily_decrypt(self, c: int, d: int = 2021):
noise = randint(1, d**2-1)
delta_p = noise % d
delta_q = noise // d
return pow(c, self.d, (self.p + delta_p) * (self.q + delta_q))
def main():
cipher = RSA()
# what is this?
print(cipher.encrypt(-1))
# you need to guess this to get flag
x = getrandbits(777)
print(cipher.encrypt(x))
# will 2021 oracle calls be enough?
for _ in range(2021):
guessed_x = int(input())
if guessed_x == x:
from secret import FLAG
print(FLAG)
return
else:
print(cipher.noisily_decrypt(abs(guessed_x)))
if __name__ == '__main__':
main()
&lt;/code>&lt;/pre>
&lt;p>First off, it&amp;rsquo;s obvious that $N = \text{cipher.encrypt}(-1) + 1$.&lt;/p>
&lt;p>Suppose that we got lucky and got a $noise$ such that $noise \equiv 0 \pmod{d}$, which means $\Delta_p = 0$. Let the noisily-decrypted result be $x'$. Also, suppose that $d$ is odd, if it isn&amp;rsquo;t, create a new session until it is odd.&lt;/p>
&lt;p>In this case, we have:&lt;/p>
&lt;p>\begin{equation}
\begin{aligned}
(N - 1)^d &amp;amp;\equiv x' \pmod{p(q + \Delta_q)} \\
\Leftrightarrow (N - 1)^d + 1 &amp;amp;\equiv x' + 1 \pmod{p(q + \Delta_q)} \\
\Leftrightarrow (N - 1)^d + 1 &amp;amp;\equiv x' + 1 \pmod{p} \\
\Leftrightarrow (-1)^d + 1 &amp;amp;\equiv x' + 1 \pmod{p} \\
\Leftrightarrow 0 &amp;amp;\equiv x' + 1 \pmod{p}
\end{aligned}
\end{equation}&lt;/p>
&lt;p>With very high probablity, $GCD(x' + 1, N)$ will be equal to $p$.&lt;/p>
&lt;p>Now, how to ensure that $noise \equiv 0 \pmod{d}$? Simple, just connect a few times until it is. $(2020/2021)^{2020} \approx 0.37$, very small.&lt;/p>
&lt;p>Solution:&lt;/p>
&lt;pre>&lt;code class="language-python">from pwn import process
from Crypto.Util.number import GCD, inverse, isPrime
with process([&amp;quot;python3&amp;quot;, &amp;quot;noise.py&amp;quot;]) as tube:
N = int(tube.recvline().decode()) + 1
enc_x = int(tube.recvline().decode())
a = []
for _ in range(2020):
tube.sendline(str(N - 1).encode())
enc = int(tube.recvline().decode())
a.append(enc)
for i in range(len(a)):
g = GCD(a[i] + 1, N)
if g &amp;gt; 1:
p = g
q = N // p
assert isPrime(p)
assert isPrime(q)
phi = (p - 1) * (q - 1)
e = 65537
d = inverse(e, phi)
x = pow(enc_x, d, N)
tube.sendline(str(x).encode())
flag = tube.recvline().decode().strip()
print(&amp;quot;Flag: &amp;quot; + flag)
break
&lt;/code>&lt;/pre>
&lt;h2 id="attackdefence-crypto01">Attack/Defence Crypto01&lt;/h2>
&lt;pre>&lt;code class="language-python">data = sp.serialize({
b&amp;quot;issuer&amp;quot;: b&amp;quot;vnsecurity&amp;quot;,
b&amp;quot;citizen_id&amp;quot;: citizen_id,
b&amp;quot;citizen_name&amp;quot;: citizen_name,
b&amp;quot;doses&amp;quot;: (0).to_bytes(1, &amp;quot;big&amp;quot;)
})
&lt;/code>&lt;/pre>
&lt;p>(&lt;code>citizen_id&lt;/code> and &lt;code>citizen_name&lt;/code> is from our input)&lt;/p>
&lt;p>The target is to submit a new data with at least 2 &lt;code>doses&lt;/code>. It&amp;rsquo;s also required to submit a MAC corresponding to the data. There are 5 types of MAC here.&lt;/p>
&lt;h3 id="aes256xormp">Aes256XorMP&lt;/h3>
&lt;p>The MAC is compute by dividing the data into blocks of size 16, encrypting each using AES-256 with the same secret key, then xor-ing all the result together. In case data length is not divisible by 16, pad the data with 0s.&lt;/p>
&lt;p>The solution is to use a &lt;code>citizen_id/citizen_name&lt;/code> such that the last byte (the byte for &lt;code>doses&lt;/code>) is at the beginning of a new block, and there exists another block in the form of &lt;code>\2 + \0*15&lt;/code>. It&amp;rsquo;s easy to see that if you swap the two block, the resulting MAC is the same, while &lt;code>doses&lt;/code> becomes 2.&lt;/p>
&lt;h3 id="crc32mp">Crc32MP&lt;/h3>
&lt;p>The MAC is compute by taking &lt;code>CRC32(secret + data)&lt;/code> where &lt;code>secret&lt;/code> is a random 32-byte pad.&lt;/p>
&lt;p>CRC32 has a property that &lt;code>CRC32(x ^ y ^ z) = CRC32(x) ^ CRC32(y) ^ CRC32(z)&lt;/code> if &lt;code>x, y, z&lt;/code> are of a same length. (&lt;a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check#Data_integrity%29" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cyclic_redundancy_check#Data_integrity)&lt;/a>. With this, we easy craft new data like this:&lt;/p>
&lt;p>Consider &lt;code>new_data&lt;/code> being &lt;code>data&lt;/code> with the last byte (for &lt;code>doses&lt;/code>) replaced with 2, in other words, &lt;code>new_data = data ^ 0 ^ 2&lt;/code>, then.&lt;/p>
&lt;p>&lt;code>CRC32(secret + new_data) = CRC32(secret + data) ^ CRC32(0) ^ CRC32(2)&lt;/code>.&lt;/p>
&lt;h3 id="dsa">DSA&lt;/h3>
&lt;p>Here is how the signature for a message $m$ is generated:&lt;/p>
&lt;pre>&lt;code class="language-python">k = int(time.time())
r = pow(g, k, p) % q
s = pow(k, -1, q) * (m + self.x * r) % q
&lt;/code>&lt;/pre>
&lt;p>We have the timestamp at the beginning of the session. That timestamp and $k$ should not differ by a lot, which means we can bruteforce $k$.&lt;/p>
&lt;p>When we have $k$, generating a signature for $m'$ is obvious:&lt;/p>
&lt;ul>
&lt;li>$r$ is the same.&lt;/li>
&lt;li>$s' = s + (k^{-1} \mod q) * (m' - m)$&lt;/li>
&lt;/ul>
&lt;h3 id="rsa">RSA&lt;/h3>
&lt;p>We are given everything ($N, e, d$), so we can just compute everything ourselves.&lt;/p>
&lt;h3 id="sha">SHA&lt;/h3>
&lt;p>The MAC is computed as &lt;code>SHA256(secret + data)&lt;/code>. It&amp;rsquo;s obvious this is length-extension attack. For Python, this github repo works fine: &lt;a href="https://github.com/stephenbradshaw/hlextend" target="_blank" rel="noopener">https://github.com/stephenbradshaw/hlextend&lt;/a>. To get the payload in bytes form, wrap the result in a &lt;code>b&amp;quot;&amp;quot;&lt;/code>, then &lt;code>eval()&lt;/code> it.&lt;/p>
&lt;h1 id="web">Web&lt;/h1>
&lt;h2 id="attackdefence-web02">Attack/Defence Web02&lt;/h2>
&lt;p>This one is quite straightforward. The one pain that I suffered is to implement curl using &lt;code>file_get_contents&lt;/code>. Why not just allow &lt;code>php-curl&lt;/code>? :(&lt;/p>
&lt;p>We have:&lt;/p>
&lt;ul>
&lt;li>A Gitlab instance. This is where the flag is. The flag can only be read using a binary &lt;code>/readflag&lt;/code>, so the target is to get RCE on this Gitlab instance.&lt;/li>
&lt;li>A PHP website. This is the only thing exposed to us.&lt;/li>
&lt;/ul>
&lt;p>The Gitlab version is 13.10.2. I remember reading on Twitter about an RCE on Gitlab recently using some sort of image thingies. A quick search returns this: CVE-2021-22205 (&lt;a href="https://pentest-tools.com/blog/detect-gitlab-cve-2021-22205/%29" target="_blank" rel="noopener">https://pentest-tools.com/blog/detect-gitlab-cve-2021-22205/)&lt;/a>.&lt;/p>
&lt;blockquote>
&lt;p>this security issue affects Gitlab CE versions starting 11.9 and up to 13.10.2&lt;/p>
&lt;/blockquote>
&lt;p>Bingo! Now we need some way to be able to make HTTP requests to the Gitlab instance. Time to look at the PHP site.&lt;/p>
&lt;p>First thing first, the site check authentication just by taking the &lt;code>user&lt;/code> cookie, strip the last 32 bytes, use the rest as username to search in database. If that username exists, we are authenticated. So the solution is to put &lt;code>'chongxun' + 'a' * 32&lt;/code> in that cookie.&lt;/p>
&lt;p>The next thing noticable is the &lt;code>/upload.php&lt;/code> route. This route allows us to upload any file that is not &lt;code>.php&lt;/code>, &lt;code>.pht&lt;/code>, or &lt;code>.phar&lt;/code>. The extension check is very thorough, there is no chance to bypass it to upload a &lt;code>.php&lt;/code> file. However, it turns out that there is another extension that can perform the same as &lt;code>.php&lt;/code>: &lt;code>.phtml&lt;/code>. We can now upload a shell to the PHP instance.&lt;/p>
&lt;p>I then wasted half an hour trying to get RCE using the uploaded shell, only to realize that &lt;code>system, exec, etc&lt;/code> are disabled in &lt;code>php.ini&lt;/code>. This means we need to do everything using pure, painful PHP. Also, &lt;code>php-curl&lt;/code> is not installed, but we can use &lt;code>file_get_contents&lt;/code> instead.&lt;/p>
&lt;p>The rest is just 4 hours of pain simulating the process of signing up, signing in, attaching file to new snippet, etc, using &lt;code>file_get_contents&lt;/code>.&lt;/p>
&lt;p>There are a few things I was able to learned from this:&lt;/p>
&lt;ul>
&lt;li>PHP is fucking stupid.&lt;/li>
&lt;li>PHP is evil.&lt;/li>
&lt;/ul>
&lt;p>For real, why is &lt;code>'\n'&lt;/code> escaped but &lt;code>&amp;quot;\n&amp;quot;&lt;/code> isn&amp;rsquo;t?. And why is the syntax for POST-ing with &lt;code>file_get_contents&lt;/code> so complicated? Why does it not take an array as headers? I had to pull up Wireshark to debug this fucking thing.&lt;/p>
&lt;p>Also, why is &lt;code>file_get_contents&lt;/code> able to POST to begin with?.&lt;/p>
&lt;p>Okay, there is still the Java chal and one more crypto chal left. The crypto challenge feels very impossible, and Java just scares me in general.&lt;/p>
&lt;p>Finally, F to my uni&amp;rsquo;s team. You did well.&lt;/p></description></item></channel></rss>