<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>crypto | Lam Nguyen's blog</title><link>https://lamnhh.github.io/tag/crypto/</link><atom:link href="https://lamnhh.github.io/tag/crypto/index.xml" rel="self" type="application/rss+xml"/><description>crypto</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Sun, 14 Nov 2021 00:00:00 +0000</lastBuildDate><image><url>https://lamnhh.github.io/media/icon_hu8b9791073e3b63e9cb38d6dd95fed664_126888_512x512_fill_lanczos_center_3.png</url><title>crypto</title><link>https://lamnhh.github.io/tag/crypto/</link></image><item><title>ASCIS 2021 Finals writeups (WIP)</title><link>https://lamnhh.github.io/post/2021-11-14-ascis2021/</link><pubDate>Sun, 14 Nov 2021 00:00:00 +0000</pubDate><guid>https://lamnhh.github.io/post/2021-11-14-ascis2021/</guid><description>&lt;p>You can download some of the binaries here: &lt;a href="https://drive.google.com/drive/folders/1q9rx2gbuZjSFzXb-_HFdaOV26zPakOAP?usp=sharing" target="_blank" rel="noopener">https://drive.google.com/drive/folders/1q9rx2gbuZjSFzXb-_HFdaOV26zPakOAP?usp=sharing&lt;/a>&lt;/p>
&lt;p>The link contains Crypto01 (buggy), Web02 (chongxun), Jeopardy Crypto01 (noise). My solutions to these challenges are also in there.&lt;/p>
&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="#crypto">Crypto&lt;/a>&lt;/p>
&lt;p>1.1. &lt;a href="#jeopardy-crypto01">Jeopardy Crypto01 (noise)&lt;/a>&lt;/p>
&lt;p>1.2. &lt;a href="#attackdefence-crypto01">Attack/Defence Crypto01&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="#web">Web&lt;/a>&lt;/p>
&lt;p>2.1. &lt;a href="#attackdefence-web02">Attack/Defence Web02&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="crypto">Crypto&lt;/h1>
&lt;h2 id="jeopardy-crypto01">Jeopardy Crypto01&lt;/h2>
&lt;pre>&lt;code class="language-python">from random import randint, getrandbits
from Crypto.Util.number import getPrime # pycryptodome
class RSA:
def __init__(self):
self.e = 65537
self.p = getPrime(512)
self.q = getPrime(512)
self.d = pow(self.e, -1, (self.p - 1) * (self.q - 1))
def encrypt(self, m: int) -&amp;gt; int:
return pow(m, self.e, self.p * self.q)
def noisily_decrypt(self, c: int, d: int = 2021):
noise = randint(1, d**2-1)
delta_p = noise % d
delta_q = noise // d
return pow(c, self.d, (self.p + delta_p) * (self.q + delta_q))
def main():
cipher = RSA()
# what is this?
print(cipher.encrypt(-1))
# you need to guess this to get flag
x = getrandbits(777)
print(cipher.encrypt(x))
# will 2021 oracle calls be enough?
for _ in range(2021):
guessed_x = int(input())
if guessed_x == x:
from secret import FLAG
print(FLAG)
return
else:
print(cipher.noisily_decrypt(abs(guessed_x)))
if __name__ == '__main__':
main()
&lt;/code>&lt;/pre>
&lt;p>First off, it&amp;rsquo;s obvious that $N = \text{cipher.encrypt}(-1) + 1$.&lt;/p>
&lt;p>Suppose that we got lucky and got a $noise$ such that $noise \equiv 0 \pmod{d}$, which means $\Delta_p = 0$. Let the noisily-decrypted result be $x'$. Also, suppose that $d$ is odd, if it isn&amp;rsquo;t, create a new session until it is odd.&lt;/p>
&lt;p>In this case, we have:&lt;/p>
&lt;p>\begin{equation}
\begin{aligned}
(N - 1)^d &amp;amp;\equiv x' \pmod{p(q + \Delta_q)} \\
\Leftrightarrow (N - 1)^d + 1 &amp;amp;\equiv x' + 1 \pmod{p(q + \Delta_q)} \\
\Leftrightarrow (N - 1)^d + 1 &amp;amp;\equiv x' + 1 \pmod{p} \\
\Leftrightarrow (-1)^d + 1 &amp;amp;\equiv x' + 1 \pmod{p} \\
\Leftrightarrow 0 &amp;amp;\equiv x' + 1 \pmod{p}
\end{aligned}
\end{equation}&lt;/p>
&lt;p>With very high probablity, $GCD(x' + 1, N)$ will be equal to $p$.&lt;/p>
&lt;p>Now, how to ensure that $noise \equiv 0 \pmod{d}$? Simple, just connect a few times until it is. $(2020/2021)^{2020} \approx 0.37$, very small.&lt;/p>
&lt;p>Solution:&lt;/p>
&lt;pre>&lt;code class="language-python">from pwn import process
from Crypto.Util.number import GCD, inverse, isPrime
with process([&amp;quot;python3&amp;quot;, &amp;quot;noise.py&amp;quot;]) as tube:
N = int(tube.recvline().decode()) + 1
enc_x = int(tube.recvline().decode())
a = []
for _ in range(2020):
tube.sendline(str(N - 1).encode())
enc = int(tube.recvline().decode())
a.append(enc)
for i in range(len(a)):
g = GCD(a[i] + 1, N)
if g &amp;gt; 1:
p = g
q = N // p
assert isPrime(p)
assert isPrime(q)
phi = (p - 1) * (q - 1)
e = 65537
d = inverse(e, phi)
x = pow(enc_x, d, N)
tube.sendline(str(x).encode())
flag = tube.recvline().decode().strip()
print(&amp;quot;Flag: &amp;quot; + flag)
break
&lt;/code>&lt;/pre>
&lt;h2 id="attackdefence-crypto01">Attack/Defence Crypto01&lt;/h2>
&lt;pre>&lt;code class="language-python">data = sp.serialize({
b&amp;quot;issuer&amp;quot;: b&amp;quot;vnsecurity&amp;quot;,
b&amp;quot;citizen_id&amp;quot;: citizen_id,
b&amp;quot;citizen_name&amp;quot;: citizen_name,
b&amp;quot;doses&amp;quot;: (0).to_bytes(1, &amp;quot;big&amp;quot;)
})
&lt;/code>&lt;/pre>
&lt;p>(&lt;code>citizen_id&lt;/code> and &lt;code>citizen_name&lt;/code> is from our input)&lt;/p>
&lt;p>The target is to submit a new data with at least 2 &lt;code>doses&lt;/code>. It&amp;rsquo;s also required to submit a MAC corresponding to the data. There are 5 types of MAC here.&lt;/p>
&lt;h3 id="aes256xormp">Aes256XorMP&lt;/h3>
&lt;p>The MAC is compute by dividing the data into blocks of size 16, encrypting each using AES-256 with the same secret key, then xor-ing all the result together. In case data length is not divisible by 16, pad the data with 0s.&lt;/p>
&lt;p>The solution is to use a &lt;code>citizen_id/citizen_name&lt;/code> such that the last byte (the byte for &lt;code>doses&lt;/code>) is at the beginning of a new block, and there exists another block in the form of &lt;code>\2 + \0*15&lt;/code>. It&amp;rsquo;s easy to see that if you swap the two block, the resulting MAC is the same, while &lt;code>doses&lt;/code> becomes 2.&lt;/p>
&lt;h3 id="crc32mp">Crc32MP&lt;/h3>
&lt;p>The MAC is compute by taking &lt;code>CRC32(secret + data)&lt;/code> where &lt;code>secret&lt;/code> is a random 32-byte pad.&lt;/p>
&lt;p>CRC32 has a property that &lt;code>CRC32(x ^ y ^ z) = CRC32(x) ^ CRC32(y) ^ CRC32(z)&lt;/code> if &lt;code>x, y, z&lt;/code> are of a same length. (&lt;a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check#Data_integrity%29" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cyclic_redundancy_check#Data_integrity)&lt;/a>. With this, we easy craft new data like this:&lt;/p>
&lt;p>Consider &lt;code>new_data&lt;/code> being &lt;code>data&lt;/code> with the last byte (for &lt;code>doses&lt;/code>) replaced with 2, in other words, &lt;code>new_data = data ^ 0 ^ 2&lt;/code>, then.&lt;/p>
&lt;p>&lt;code>CRC32(secret + new_data) = CRC32(secret + data) ^ CRC32(0) ^ CRC32(2)&lt;/code>.&lt;/p>
&lt;h3 id="dsa">DSA&lt;/h3>
&lt;p>Here is how the signature for a message $m$ is generated:&lt;/p>
&lt;pre>&lt;code class="language-python">k = int(time.time())
r = pow(g, k, p) % q
s = pow(k, -1, q) * (m + self.x * r) % q
&lt;/code>&lt;/pre>
&lt;p>We have the timestamp at the beginning of the session. That timestamp and $k$ should not differ by a lot, which means we can bruteforce $k$.&lt;/p>
&lt;p>When we have $k$, generating a signature for $m'$ is obvious:&lt;/p>
&lt;ul>
&lt;li>$r$ is the same.&lt;/li>
&lt;li>$s' = s + (k^{-1} \mod q) * (m' - m)$&lt;/li>
&lt;/ul>
&lt;h3 id="rsa">RSA&lt;/h3>
&lt;p>We are given everything ($N, e, d$), so we can just compute everything ourselves.&lt;/p>
&lt;h3 id="sha">SHA&lt;/h3>
&lt;p>The MAC is computed as &lt;code>SHA256(secret + data)&lt;/code>. It&amp;rsquo;s obvious this is length-extension attack. For Python, this github repo works fine: &lt;a href="https://github.com/stephenbradshaw/hlextend" target="_blank" rel="noopener">https://github.com/stephenbradshaw/hlextend&lt;/a>. To get the payload in bytes form, wrap the result in a &lt;code>b&amp;quot;&amp;quot;&lt;/code>, then &lt;code>eval()&lt;/code> it.&lt;/p>
&lt;h1 id="web">Web&lt;/h1>
&lt;h2 id="attackdefence-web02">Attack/Defence Web02&lt;/h2>
&lt;p>This one is quite straightforward. The one pain that I suffered is to implement curl using &lt;code>file_get_contents&lt;/code>. Why not just allow &lt;code>php-curl&lt;/code>? :(&lt;/p>
&lt;p>We have:&lt;/p>
&lt;ul>
&lt;li>A Gitlab instance. This is where the flag is. The flag can only be read using a binary &lt;code>/readflag&lt;/code>, so the target is to get RCE on this Gitlab instance.&lt;/li>
&lt;li>A PHP website. This is the only thing exposed to us.&lt;/li>
&lt;/ul>
&lt;p>The Gitlab version is 13.10.2. I remember reading on Twitter about an RCE on Gitlab recently using some sort of image thingies. A quick search returns this: CVE-2021-22205 (&lt;a href="https://pentest-tools.com/blog/detect-gitlab-cve-2021-22205/%29" target="_blank" rel="noopener">https://pentest-tools.com/blog/detect-gitlab-cve-2021-22205/)&lt;/a>.&lt;/p>
&lt;blockquote>
&lt;p>this security issue affects Gitlab CE versions starting 11.9 and up to 13.10.2&lt;/p>
&lt;/blockquote>
&lt;p>Bingo! Now we need some way to be able to make HTTP requests to the Gitlab instance. Time to look at the PHP site.&lt;/p>
&lt;p>First thing first, the site check authentication just by taking the &lt;code>user&lt;/code> cookie, strip the last 32 bytes, use the rest as username to search in database. If that username exists, we are authenticated. So the solution is to put &lt;code>'chongxun' + 'a' * 32&lt;/code> in that cookie.&lt;/p>
&lt;p>The next thing noticable is the &lt;code>/upload.php&lt;/code> route. This route allows us to upload any file that is not &lt;code>.php&lt;/code>, &lt;code>.pht&lt;/code>, or &lt;code>.phar&lt;/code>. The extension check is very thorough, there is no chance to bypass it to upload a &lt;code>.php&lt;/code> file. However, it turns out that there is another extension that can perform the same as &lt;code>.php&lt;/code>: &lt;code>.phtml&lt;/code>. We can now upload a shell to the PHP instance.&lt;/p>
&lt;p>I then wasted half an hour trying to get RCE using the uploaded shell, only to realize that &lt;code>system, exec, etc&lt;/code> are disabled in &lt;code>php.ini&lt;/code>. This means we need to do everything using pure, painful PHP. Also, &lt;code>php-curl&lt;/code> is not installed, but we can use &lt;code>file_get_contents&lt;/code> instead.&lt;/p>
&lt;p>The rest is just 4 hours of pain simulating the process of signing up, signing in, attaching file to new snippet, etc, using &lt;code>file_get_contents&lt;/code>.&lt;/p>
&lt;p>There are a few things I was able to learned from this:&lt;/p>
&lt;ul>
&lt;li>PHP is fucking stupid.&lt;/li>
&lt;li>PHP is evil.&lt;/li>
&lt;/ul>
&lt;p>For real, why is &lt;code>'\n'&lt;/code> escaped but &lt;code>&amp;quot;\n&amp;quot;&lt;/code> isn&amp;rsquo;t?. And why is the syntax for POST-ing with &lt;code>file_get_contents&lt;/code> so complicated? Why does it not take an array as headers? I had to pull up Wireshark to debug this fucking thing.&lt;/p>
&lt;p>Also, why is &lt;code>file_get_contents&lt;/code> able to POST to begin with?.&lt;/p>
&lt;p>Okay, there is still the Java chal and one more crypto chal left. The crypto challenge feels very impossible, and Java just scares me in general.&lt;/p>
&lt;p>Finally, F to my uni&amp;rsquo;s team. You did well.&lt;/p></description></item><item><title>Recover public keys from JWTs signed using RS256</title><link>https://lamnhh.github.io/post/2021-02-22-jwt-rs256-recover-public-key/</link><pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate><guid>https://lamnhh.github.io/post/2021-02-22-jwt-rs256-recover-public-key/</guid><description>&lt;h1 id="scenario">Scenario&lt;/h1>
&lt;p>A web server uses RS256 algorithm for their JWT signing. Both public key and private key are unknown. The adversary can query the server to sign a chosen message. The goal is to recover the public key.&lt;/p>
&lt;h1 id="how-jwt-works">How JWT works&lt;/h1>
&lt;p>Take a look at a sample JWT:&lt;/p>
&lt;pre>&lt;code>eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdGF0dXMiOiJicm9uemUiLCJmZnAiOiJDQTEyMzQxMjM0In0.jv953fHSWqvR7SY8l3g2ku_BRAXqIvKOIq_lAjPXWXgUeIml6myJeRmqoSkDZ3-YpyyQ2hQxTuBip8igyhOHz0dc6A08Psip1KuqVjnilywN1JcH0euXGVQeeI-FwdeIArPwfoDUFXXKz8sh3EO9gK6dAwmWGLAV4wMF50fVjb7WuHEiL6w9WOeKfBneV4_3skDm8ljXoGGGyP7YkL6ez-fwacIe7_m-4MuQdfZfO1t-g2Vjr-yaImUHrZyW9Q8cAM3eJZ7m0UCnb8pG5yd8rU5vcXovKrbX6ZIYwaw4-IvFtJdU6h2jXwm2uKjRnhfYezi_iKARFO2Mv3vJmkX-Kg
&lt;/code>&lt;/pre>
&lt;p>It consists of 3 parts:&lt;/p>
&lt;p>Header:&lt;/p>
&lt;pre>&lt;code>eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9
&lt;/code>&lt;/pre>
&lt;p>Payload:&lt;/p>
&lt;pre>&lt;code>eyJzdGF0dXMiOiJicm9uemUiLCJmZnAiOiJDQTEyMzQxMjM0In0
&lt;/code>&lt;/pre>
&lt;p>Signature:&lt;/p>
&lt;pre>&lt;code>jv953fHSWqvR7SY8l3g2ku_BRAXqIvKOIq_lAjPXWXgUeIml6myJeRmqoSkDZ3-YpyyQ2hQxTuBip8igyhOHz0dc6A08Psip1KuqVjnilywN1JcH0euXGVQeeI-FwdeIArPwfoDUFXXKz8sh3EO9gK6dAwmWGLAV4wMF50fVjb7WuHEiL6w9WOeKfBneV4_3skDm8ljXoGGGyP7YkL6ez-fwacIe7_m-4MuQdfZfO1t-g2Vjr-yaImUHrZyW9Q8cAM3eJZ7m0UCnb8pG5yd8rU5vcXovKrbX6ZIYwaw4-IvFtJdU6h2jXwm2uKjRnhfYezi_iKARFO2Mv3vJmkX-Kg
&lt;/code>&lt;/pre>
&lt;p>Each of these part is base64-ed. The signature is computed on &lt;code>Header + &amp;quot;.&amp;quot; + Payload&lt;/code>. The signing algorithm is specified in the raw header (in the sample above, it&amp;rsquo;s RS256 - RSA with SHA256).&lt;/p>
&lt;h1 id="how-rs256-works">How RS256 works&lt;/h1>
&lt;p>RS256 - RSA with SHA256 does the following:&lt;/p>
&lt;ul>
&lt;li>Encode the message using EMSA-PKCS1-v1_5 (&lt;a href="https://tools.ietf.org/html/rfc3447#section-9.2" target="_blank" rel="noopener">RFC3447, section9.2&lt;/a>) with SHA256 as the hash function&lt;/li>
&lt;li>Perform textbook RSA signing on the encoded message&lt;/li>
&lt;/ul>
&lt;h2 id="more-detail-on-the-rsa-part">More detail on the RSA part&lt;/h2>
&lt;p>Given the key $(N, e, d)$, the signature for message $m$ is computed as:&lt;/p>
&lt;p>$$s = m^d \pmod{N}$$&lt;/p>
&lt;p>To verify the signature, check if:&lt;/p>
&lt;p>$$
\begin{equation}
s^e \equiv m^{de} \equiv m \pmod{N}
\label{eq:sample}
\tag{*}
\end{equation}
$$&lt;/p>
&lt;h1 id="the-attack">The attack&lt;/h1>
&lt;p>From $(*)$, we can see that:&lt;/p>
&lt;p>$$s^e - m \equiv 0 \pmod{N}$$&lt;/p>
&lt;p>Given a lot of $(message, signature)$ pairs $(m_1, s_1), (m_2, s_2), &amp;hellip;, (m_k, s_k)$, with high chance, we will get $N$ when we compute:&lt;/p>
&lt;p>$$GCD(s_1^e - m_1, s_2^e - m_2, &amp;hellip;, s_k^e - m_k)$$&lt;/p>
&lt;h2 id="_where-does-e-come-from_">&lt;strong>&lt;em>Where does e come from?&lt;/em>&lt;/strong>&lt;/h2>
&lt;p>$e$ is usually in the form $2^{2^k} + 1$ with small $k$. We can bruteforce $e$.&lt;/p>
&lt;h2 id="_when-can-this-attack-be-fatal_">&lt;strong>&lt;em>When can this attack be fatal?&lt;/em>&lt;/strong>&lt;/h2>
&lt;p>When the server uses a JWT library that is vulnerable to key confusion (can use RSA key to decode HS256 tokens), for example, CVE-2016-10555 or CVE-2017-11424.&lt;/p>
&lt;p>In those cases, the attacker can modify the &lt;code>alg&lt;/code> field to HS256 in the header, change the payload however they want, then sign it with the public key with HS256 algorithm. The server will decode the token using the public key, thus giving the attacker authentication.&lt;/p>
&lt;h2 id="_notes-about-implementation_">&lt;strong>&lt;em>Notes about implementation&lt;/em>&lt;/strong>&lt;/h2>
&lt;p>JWT keys are usually large (at least 2048 bit long). Computing $s^e$ can be very slow. For Python, use &lt;code>mpz&lt;/code> from &lt;code>gmpy2&lt;/code> to speed up things.&lt;/p>
&lt;p>Sample implementation (writeup for the Cr0wnAir challenge (the crypto part) from &lt;a href="https://ctftime.org/event/1246" target="_blank" rel="noopener">UnionCTF 2021&lt;/a>):&lt;/p>
&lt;pre>&lt;code class="language-python">from Crypto.Signature import PKCS1_v1_5
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA256
from Crypto.Util.number import bytes_to_long, long_to_bytes
from base64 import b64decode, urlsafe_b64decode
from gmpy2 import gcd, mpz
target_bit_length = 2048
jwt_list = [
&amp;quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdGF0dXMiOiJicm9uemUiLCJmZnAiOiJDQTEyMzQxMjM0In0.jv953fHSWqvR7SY8l3g2ku_BRAXqIvKOIq_lAjPXWXgUeIml6myJeRmqoSkDZ3-YpyyQ2hQxTuBip8igyhOHz0dc6A08Psip1KuqVjnilywN1JcH0euXGVQeeI-FwdeIArPwfoDUFXXKz8sh3EO9gK6dAwmWGLAV4wMF50fVjb7WuHEiL6w9WOeKfBneV4_3skDm8ljXoGGGyP7YkL6ez-fwacIe7_m-4MuQdfZfO1t-g2Vjr-yaImUHrZyW9Q8cAM3eJZ7m0UCnb8pG5yd8rU5vcXovKrbX6ZIYwaw4-IvFtJdU6h2jXwm2uKjRnhfYezi_iKARFO2Mv3vJmkX-Kg&amp;quot;,
&amp;quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdGF0dXMiOiJicm9uemUiLCJmZnAiOiJDQTEyMzQxMjM1In0.vtp96NW_PxO-_GW2e1u0xu4FTMYjYgwfe2wYKuksUGE_lM1ZeiyitDiUMXaQ3s5T3pD9ALHcqpsBY-5z1DbxVgPMvrqaExnw0merTDm17ku3b0ys5-dJOybb0meI7eu4i-Qykh0X_XHyOlxT6H-ZyxCcKov9sbnJVk3fbZY2lzjKuYZAIYQzXd5J65GooA7vkR2cWeK6rypHFyDPtuFaPLOhE6cLbC9VVyD4oxu0bvkpW6lRuiQni-S4uMkH2y7OUA16nNNVVwixUGVPwzGW8oS61lXiA3OHp1o336cyKJ9B4_ae1FeClPgUAnH_CWQIoZzco2Jb3mnHFq7lVgBnug&amp;quot;,
]
def b64urldecode(b64: str) -&amp;gt; str:
return urlsafe_b64decode(b64+(&amp;quot;=&amp;quot; * (len(b64) % 4)))
def parse(jwt: str) -&amp;gt; (bytes, bytes):
tokens = jwt.split(&amp;quot;.&amp;quot;)
return &amp;quot;.&amp;quot;.join(tokens[0:2]), b64urldecode(tokens[2])
def get_rsa_mc(jwt: str) -&amp;gt; int:
inp, sig = parse(jwt)
h = SHA256.new(inp.encode())
m = bytes_to_long(
PKCS1_v1_5.pkcs1_15._EMSA_PKCS1_V1_5_ENCODE(h, target_bit_length // 8)
)
c = bytes_to_long(sig)
return mpz(m), mpz(c)
def get_pubkey(n: int, e: int) -&amp;gt; str:
k = RSA.construct([n, e])
return k.export_key(&amp;quot;PEM&amp;quot;)
ms = []
cs = []
for jwt in jwt_list:
m, c = get_rsa_mc(jwt)
ms.append(m)
cs.append(c)
assert len(ms) &amp;gt; 0 and len(cs) == len(ms)
e = 65537
n = pow(cs[0], e) - ms[0]
for i in range(1, len(ms)):
m = ms[i]
c = cs[i]
n = gcd(n, pow(c, e) - m)
for i in range(2, 1000):
while n % i == 0:
n //= i
n = int(n)
print(n)
print(get_pubkey(n, e))
&lt;/code>&lt;/pre>
&lt;h2 id="_lessons_">&lt;strong>&lt;em>Lessons&lt;/em>&lt;/strong>&lt;/h2>
&lt;ul>
&lt;li>Do not rely on public keys for security purposes.&lt;/li>
&lt;li>Be careful when using JWT. Or even better, don&amp;rsquo;t use them.&lt;/li>
&lt;/ul>
&lt;h1 id="references">References&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://blog.silentsignal.eu/2021/02/08/abusing-jwt-public-keys-without-the-public-key/" target="_blank" rel="noopener">Abusing JWT public keys without the public key&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>ASCIS 2020 - Crypto writeups</title><link>https://lamnhh.github.io/post/2021-01-09-ascis2020-crypto/</link><pubDate>Sat, 09 Jan 2021 00:00:00 +0000</pubDate><guid>https://lamnhh.github.io/post/2021-01-09-ascis2020-crypto/</guid><description>&lt;p>This is me upsolving the challenges 1 month after the contest. All patches are unavailable to download, so all I discuss here is how to attack the original challenges (with no patches).&lt;/p>
&lt;p>The challenge can be summarised as:&lt;/p>
&lt;ul>
&lt;li>Given an oracle $E$ which we can query: give it a string $s$ and it will return $E(s)$.&lt;/li>
&lt;li>The target is to forge $E(target)$ where&lt;/li>
&lt;/ul>
&lt;p>$$target = \text{0x2020202020202020202020202020202020202020202020202020202020202020}$$&lt;/p>
&lt;p>(32 bytes 0x20). The catch is that we cannot query for $E(target)$ directly.&lt;/p>
&lt;p>There are 3 oracles we need to attack:&lt;/p>
&lt;ul>
&lt;li>AES-CBC 256&lt;/li>
&lt;li>AES-GCM 256&lt;/li>
&lt;li>RSA on Gaussian integers&lt;/li>
&lt;/ul>
&lt;h1 id="aes-cbc-256">AES-CBC 256&lt;/h1>
&lt;p>
&lt;figure id="figure-cbc-encryption">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/80/CBC_encryption.svg/1920px-CBC_encryption.svg.png" alt="CBC Encryption" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
CBC Encryption
&lt;/figcaption>&lt;/figure>
&lt;/p>
&lt;p>The oracle randomises its IV, requires the plaintext to be exactly 32 bytes long (2 blocks), which means it will feed into the cipher 3 blocks of data (because of padding). We have the exact flowchart as the image above.&lt;/p>
&lt;p>The solution is:&lt;/p>
&lt;ul>
&lt;li>First, query $E(00 * 16 + 20 * 16)$, we get back $IV$ and $CT$.&lt;/li>
&lt;li>Second, compute $IV' = IV \oplus (20 * 16)$.&lt;/li>
&lt;li>Submit $IV' + CT$ and get the flag.&lt;/li>
&lt;/ul>
&lt;p>Explanation: call the first block of plaintext $PT$. For our plaintext, we have $PT = 00 * 16$.&lt;/p>
&lt;p>We can see that:&lt;/p>
&lt;p>$PT \oplus IV = (PT \oplus (20 * 16)) \oplus (IV \oplus (20 * 16)) = (target PT) \oplus IV'$&lt;/p>
&lt;p>What this means is that using target PT and IV', we have the same first block of ciphertext as above. The rest blocks will subsequently be the same. Now we have the full ciphertext for $target$.&lt;/p>
&lt;h1 id="aes-gcm-256">AES-GCM 256&lt;/h1>
&lt;p>
&lt;figure id="figure-gcm-encryption">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/25/GCM-Galois_Counter_Mode_with_IV.svg/800px-GCM-Galois_Counter_Mode_with_IV.svg.png" alt="GCM encryption" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
GCM encryption
&lt;/figcaption>&lt;/figure>
&lt;/p>
&lt;p>GCM summarised: first encrypt the plaintext using CTR mode, then use ciphertext blocks as coefficients for a polynomial, compute it on a key-dependent point H, encrypt it, then return as an authentication tag.&lt;/p>
&lt;p>This challenge is quite different from the other two. First, we look at the secret key initialisation:&lt;/p>
&lt;pre>&lt;code class="language-python">with open(&amp;quot;/opt/flag/secret&amp;quot;, &amp;quot;rb&amp;quot;) as f:
tp = Aes256GcmTP(f.read())
&lt;/code>&lt;/pre>
&lt;p>This means the secret key is the same over all connections.&lt;/p>
&lt;p>Second, nonce initialisation:&lt;/p>
&lt;pre>&lt;code class="language-python"># this is the best way to avoid nonce reuse
now = int(time())
if now &amp;lt;= self.last_timestamp:
now = self.last_timestamp + 1
self.last_timestamp = now
nonce = now.to_bytes(12, &amp;quot;big&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>This obviously can be bypassed using race condition.&lt;/p>
&lt;p>Now we have an GCM oracle that uses same secret key and same nonce for all queries. That means the encryption is a stream cipher with same key $\Rightarrow$ we can forge ciphertext however we like.&lt;/p>
&lt;p>To forge the authentication tag, we need to look more closely at the math. The tag is computed as follow:&lt;/p>
&lt;ul>
&lt;li>Compute $H = E(0^{128})$.&lt;/li>
&lt;li>Compute $pad = E(nonce | 0^{31} | 1)$.&lt;/li>
&lt;li>Call $c_1, c_2$ the two blocks of the ciphertext.&lt;/li>
&lt;li>The tag is: $c_1 \cdot H^3 + c_2 \cdot H^2 + (len(A) | len(C)) \cdot H + pad$&lt;/li>
&lt;/ul>
&lt;p>Here we have $len(A) = 0, len(C) = 32 * 8 = 256$. All computation is on $GF(2^{128})$. This is a field, which means it has distributivity, a.k.a. $A(B+C) = AB + AC$. That means, consider 3 same-length ciphertext $c^1, c^2, c^3$, we have:&lt;/p>
&lt;p>$tag(c^1) + tag(c^2) + tag(c^3)$
$= (c^1_1 + c^2_1 + c^3_1) \cdot H^3 + (c^1_2 + c^2_2 + c^3_2) \cdot H_2 + (len(A) | len(C)) \cdot H + pad$
$= tag(c^1 + c^2 + c^3) $&lt;/p>
&lt;p>&lt;em>(reminder that addition in $GF(2^n)$ is the XOR operation)&lt;/em>&lt;/p>
&lt;p>Define $et = E(target)$ (ciphertext for $target$). If we can forge these 3 values:&lt;/p>
&lt;ul>
&lt;li>&lt;code>c1 = et[:16] + 00 * 16&lt;/code>&lt;/li>
&lt;li>&lt;code>c2 = 00 * 16 + et[16:]&lt;/code>&lt;/li>
&lt;li>&lt;code>c3 = 00 * 32&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>then we have $tag(c^1) + tag(c^2) + tag(c^3) = tag(c^1 + c^2 + c^3) = tag(E(target))$&lt;/p>
&lt;p>To construct $c^1, c^2, c^3$ we do as follow:&lt;/p>
&lt;ul>
&lt;li>Define $p = random(32 bytes)$&lt;/li>
&lt;li>Query $E(p)$.&lt;/li>
&lt;li>Compute $E(target) = E(p) \oplus p \oplus target$.&lt;/li>
&lt;li>Compute $p^1 = target \oplus (E(target)[:16] | (00 * 16))$&lt;/li>
&lt;li>Compute $p^2 = target \oplus ((00 * 16) | E(target)[16:])$&lt;/li>
&lt;li>Compute $p^3 = target \oplus E(target)$&lt;/li>
&lt;/ul>
&lt;p>Then it&amp;rsquo;s easy to see that $E(p^i) = c^i$.&lt;/p>
&lt;h1 id="rsa-with-gaussian-integers">RSA with Gaussian integers&lt;/h1>
&lt;p>The string we submit is split into 2 halves, each converted to an integer, combined together into a Complex number. This complex number is then RSA-ed, concatenated, and returned to us.&lt;/p>
&lt;p>We do not know $N$ and $e$.&lt;/p>
&lt;p>The multiplication function is this:&lt;/p>
&lt;pre>&lt;code class="language-python">def complex_mult(c1, c2, modulus):
return Complex(
(c1.re * c2.re - c1.im * c2.im) % modulus, # real part
(c1.re * c2.im + c1.im * c2.re) % modulus, # image part
)
&lt;/code>&lt;/pre>
&lt;p>We define $norm(a) = a.re^2 + a.im^2$.&lt;/p>
&lt;p>It&amp;rsquo;s easy to see that $norm$ is multiplicative. In other word: $norm(c1 \cdot c2) = norm(c1) \cdot norm(c2)$. This means that we have:&lt;/p>
&lt;p>$norm(s)^e \equiv norm(s^e) \equiv norm(E(s))\ (mod\ N)$&lt;/p>
&lt;p>which is regular RSA.&lt;/p>
&lt;p>To find $N$, we query 3 values: $E(2), E(4), E(8)$. We can see that:&lt;/p>
&lt;p>\begin{equation}
\begin{aligned}
E(2) \cdot E(2)
&amp;amp;\equiv 2^e \cdot 2^e \\
&amp;amp;\equiv 4^e \\
&amp;amp;\equiv E(4) \pmod N \\
\Leftrightarrow E(2)^2 - E(4) &amp;amp;\equiv 0\ \pmod N \\
\\
E(2) \cdot E(2) \cdot E(2)
&amp;amp;\equiv 2^e \cdot 2^e \cdot 2^e \\
&amp;amp;\equiv 8^e \\
&amp;amp;\equiv E(8) \pmod N \\
\Leftrightarrow E(2)^3 - E(8) &amp;amp;\equiv 0 \pmod N
\end{aligned}
\end{equation}&lt;/p>
&lt;p>From that, we have:&lt;/p>
&lt;p>$$N \mid GCD(E(2)^2 - E(4), E(2)^3 - E(8))$$&lt;/p>
&lt;p>Define $g = GCD(E(2)^2 - E(4), E(2)^3 - E(8))$. By experiment, we can see that most prime factors of $g$ (except for $p, q$) is small (no greater than 1000). We now have $N$. Then I spent the next 12 hours struggling to compute $e$, only to realise that I don&amp;rsquo;t need it :(&lt;/p>
&lt;p>It&amp;rsquo;s easy to see that:&lt;/p>
&lt;p>\begin{equation}
\begin{aligned}
E(2target) &amp;amp;\equiv E(2) \cdot E(target) \pmod N \\
\Leftrightarrow E(target) &amp;amp;\equiv E(2target) \cdot E(2)^{-1} \pmod N
\end{aligned}
\end{equation}&lt;/p>
&lt;p>$E(2)^{-1}\ mod\ N$ can be easily computed using extended Euclid alg (we already have $E(2)$ and $N$).&lt;/p>
&lt;p>Done.&lt;/p>
&lt;style>
.medium-zoom-image {
background-color: #fff;
}
&lt;/style></description></item></channel></rss>