[{"authors":null,"categories":null,"content":"General Kenobi A wannabe hacker lmao. Currently enjoying CTFs a lot, but have no idea how/where to start with real-world stuff.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"General Kenobi A wannabe hacker lmao. Currently enjoying CTFs a lot, but have no idea how/where to start with real-world stuff.","tags":null,"title":"Lam Nguyen","type":"authors"},{"authors":null,"categories":null,"content":"owo\n","date":1632009600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1632009600,"objectID":"ae78900d75093dc47d2678306867f837","permalink":"https://lamnhh.github.io/post/2021-09-20-acsc2021/","publishdate":"2021-09-19T00:00:00Z","relpermalink":"/post/2021-09-20-acsc2021/","section":"post","summary":"owo","tags":["ctf","crypto"],"title":"ACSC 2021 writeups","type":"post"},{"authors":null,"categories":null,"content":"Scenario A web server uses RS256 algorithm for their JWT signing. Both public key and private key are unknown. The adversary can query the server to sign a chosen message. The goal is to recover the public key.\nHow JWT works Take a look at a sample JWT:\neyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdGF0dXMiOiJicm9uemUiLCJmZnAiOiJDQTEyMzQxMjM0In0.jv953fHSWqvR7SY8l3g2ku_BRAXqIvKOIq_lAjPXWXgUeIml6myJeRmqoSkDZ3-YpyyQ2hQxTuBip8igyhOHz0dc6A08Psip1KuqVjnilywN1JcH0euXGVQeeI-FwdeIArPwfoDUFXXKz8sh3EO9gK6dAwmWGLAV4wMF50fVjb7WuHEiL6w9WOeKfBneV4_3skDm8ljXoGGGyP7YkL6ez-fwacIe7_m-4MuQdfZfO1t-g2Vjr-yaImUHrZyW9Q8cAM3eJZ7m0UCnb8pG5yd8rU5vcXovKrbX6ZIYwaw4-IvFtJdU6h2jXwm2uKjRnhfYezi_iKARFO2Mv3vJmkX-Kg  It consists of 3 parts:\nHeader:\neyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9  Payload:\neyJzdGF0dXMiOiJicm9uemUiLCJmZnAiOiJDQTEyMzQxMjM0In0  Signature:\njv953fHSWqvR7SY8l3g2ku_BRAXqIvKOIq_lAjPXWXgUeIml6myJeRmqoSkDZ3-YpyyQ2hQxTuBip8igyhOHz0dc6A08Psip1KuqVjnilywN1JcH0euXGVQeeI-FwdeIArPwfoDUFXXKz8sh3EO9gK6dAwmWGLAV4wMF50fVjb7WuHEiL6w9WOeKfBneV4_3skDm8ljXoGGGyP7YkL6ez-fwacIe7_m-4MuQdfZfO1t-g2Vjr-yaImUHrZyW9Q8cAM3eJZ7m0UCnb8pG5yd8rU5vcXovKrbX6ZIYwaw4-IvFtJdU6h2jXwm2uKjRnhfYezi_iKARFO2Mv3vJmkX-Kg  Each of these part is base64-ed. The signature is computed on Header + \u0026quot;.\u0026quot; + Payload. The signing algorithm is specified in the raw header (in the sample above, it\u0026rsquo;s RS256 - RSA with SHA256).\nHow RS256 works RS256 - RSA with SHA256 does the following:\n Encode the message using EMSA-PKCS1-v1_5 (RFC3447, section9.2) with SHA256 as the hash function Perform textbook RSA signing on the encoded message  More detail on the RSA part Given the key $(N, e, d)$, the signature for message $m$ is computed as:\n$$s = m^d \\pmod{N}$$\nTo verify the signature, check if:\n$$ \\begin{equation} s^e \\equiv m^{de} \\equiv m \\pmod{N} \\label{eq:sample} \\tag{*} \\end{equation} $$\nThe attack From $(*)$, we can see that:\n$$s^e - m \\equiv 0 \\pmod{N}$$\nGiven a lot of $(message, signature)$ pairs $(m_1, s_1), (m_2, s_2), \u0026hellip;, (m_k, s_k)$, with high chance, we will get $N$ when we compute:\n$$GCD(s_1^e - m_1, s_2^e - m_2, \u0026hellip;, s_k^e - m_k)$$\nWhere does e come from? $e$ is usually in the form $2^{2^k} + 1$ with small $k$. We can bruteforce $e$.\nWhen can this attack be fatal? When the server uses a JWT library that is vulnerable to key confusion (can use RSA key to decode HS256 tokens), for example, CVE-2016-10555 or CVE-2017-11424.\nIn those cases, the attacker can modify the alg field to HS256 in the header, change the payload however they want, then sign it with the public key with HS256 algorithm. The server will decode the token using the public key, thus giving the attacker authentication.\nNotes about implementation JWT keys are usually large (at least 2048 bit long). Computing $s^e$ can be very slow. For Python, use mpz from gmpy2 to speed up things.\nSample implementation (writeup for the Cr0wnAir challenge (the crypto part) from UnionCTF 2021):\nfrom Crypto.Signature import PKCS1_v1_5 from Crypto.PublicKey import RSA from Crypto.Hash import SHA256 from Crypto.Util.number import bytes_to_long, long_to_bytes from base64 import b64decode, urlsafe_b64decode from gmpy2 import gcd, mpz target_bit_length = 2048 jwt_list = [ \u0026quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdGF0dXMiOiJicm9uemUiLCJmZnAiOiJDQTEyMzQxMjM0In0.jv953fHSWqvR7SY8l3g2ku_BRAXqIvKOIq_lAjPXWXgUeIml6myJeRmqoSkDZ3-YpyyQ2hQxTuBip8igyhOHz0dc6A08Psip1KuqVjnilywN1JcH0euXGVQeeI-FwdeIArPwfoDUFXXKz8sh3EO9gK6dAwmWGLAV4wMF50fVjb7WuHEiL6w9WOeKfBneV4_3skDm8ljXoGGGyP7YkL6ez-fwacIe7_m-4MuQdfZfO1t-g2Vjr-yaImUHrZyW9Q8cAM3eJZ7m0UCnb8pG5yd8rU5vcXovKrbX6ZIYwaw4-IvFtJdU6h2jXwm2uKjRnhfYezi_iKARFO2Mv3vJmkX-Kg\u0026quot;, \u0026quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdGF0dXMiOiJicm9uemUiLCJmZnAiOiJDQTEyMzQxMjM1In0.vtp96NW_PxO-_GW2e1u0xu4FTMYjYgwfe2wYKuksUGE_lM1ZeiyitDiUMXaQ3s5T3pD9ALHcqpsBY-5z1DbxVgPMvrqaExnw0merTDm17ku3b0ys5-dJOybb0meI7eu4i-Qykh0X_XHyOlxT6H-ZyxCcKov9sbnJVk3fbZY2lzjKuYZAIYQzXd5J65GooA7vkR2cWeK6rypHFyDPtuFaPLOhE6cLbC9VVyD4oxu0bvkpW6lRuiQni-S4uMkH2y7OUA16nNNVVwixUGVPwzGW8oS61lXiA3OHp1o336cyKJ9B4_ae1FeClPgUAnH_CWQIoZzco2Jb3mnHFq7lVgBnug\u0026quot;, ] def b64urldecode(b64: str) -\u0026gt; str: return urlsafe_b64decode(b64+(\u0026quot;=\u0026quot; * (len(b64) % 4))) def parse(jwt: str) -\u0026gt; (bytes, bytes): tokens = jwt.split(\u0026quot;.\u0026quot;) return \u0026quot;.\u0026quot;.join(tokens[0:2]), b64urldecode(tokens[2]) def get_rsa_mc(jwt: str) -\u0026gt; int: inp, sig = parse(jwt) h = SHA256.new(inp.encode()) m = bytes_to_long( PKCS1_v1_5.pkcs1_15._EMSA_PKCS1_V1_5_ENCODE(h, target_bit_length // 8) ) c = bytes_to_long(sig) return mpz(m), mpz(c) def get_pubkey(n: int, e: int) -\u0026gt; str: k = RSA.construct([n, e]) return k.export_key(\u0026quot;PEM\u0026quot;) ms = [] cs = [] for jwt in jwt_list: m, c = get_rsa_mc(jwt) ms.append(m) cs.append(c) assert len(ms) \u0026gt; 0 and len(cs) == len(ms) e = 65537 n = pow(cs[0], e) - ms[0] for i in range(1, len(ms)): m = ms[i] c = cs[i] n = gcd(n, pow(c, e) - m) for i in range(2, 1000): while n % i == 0: n //= i n = int(n) print(n) print(get_pubkey(n, e))  Lessons  Do not rely on public keys for security purposes. Be careful when using JWT. Or even better, don\u0026rsquo;t use them.  References  Abusing JWT public keys without the public key  ","date":1613952e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1613952e3,"objectID":"ec0159ed10e5cbc987a964fa80d4ae87","permalink":"https://lamnhh.github.io/post/2021-02-22-jwt-rs256-recover-public-key/","publishdate":"2021-02-22T00:00:00Z","relpermalink":"/post/2021-02-22-jwt-rs256-recover-public-key/","section":"post","summary":"Scenario A web server uses RS256 algorithm for their JWT signing. Both public key and private key are unknown. The adversary can query the server to sign a chosen message. The goal is to recover the public key.","tags":["ctf","crypto"],"title":"Recover public keys from JWTs signed using RS256","type":"post"},{"authors":null,"categories":null,"content":"This is me upsolving the challenges 1 month after the contest. All patches are unavailable to download, so all I discuss here is how to attack the original challenges (with no patches).\nThe challenge can be summarised as:\n Given an oracle $E$ which we can query: give it a string $s$ and it will return $E(s)$. The target is to forge $E(target)$ where  $$target = \\text{0x2020202020202020202020202020202020202020202020202020202020202020}$$\n(32 bytes 0x20). The catch is that we cannot query for $E(target)$ directly.\nThere are 3 oracles we need to attack:\n AES-CBC 256 AES-GCM 256 RSA on Gaussian integers  AES-CBC 256    CBC Encryption  The oracle randomises its IV, requires the plaintext to be exactly 32 bytes long (2 blocks), which means it will feed into the cipher 3 blocks of data (because of padding). We have the exact flowchart as the image above.\nThe solution is:\n First, query $E(00 * 16 + 20 * 16)$, we get back $IV$ and $CT$. Second, compute $IV' = IV \\oplus (20 * 16)$. Submit $IV' + CT$ and get the flag.  Explanation: call the first block of plaintext $PT$. For our plaintext, we have $PT = 00 * 16$.\nWe can see that:\n$PT \\oplus IV = (PT \\oplus (20 * 16)) \\oplus (IV \\oplus (20 * 16)) = (target PT) \\oplus IV'$\nWhat this means is that using target PT and IV', we have the same first block of ciphertext as above. The rest blocks will subsequently be the same. Now we have the full ciphertext for $target$.\nAES-GCM 256    GCM encryption  GCM summarised: first encrypt the plaintext using CTR mode, then use ciphertext blocks as coefficients for a polynomial, compute it on a key-dependent point H, encrypt it, then return as an authentication tag.\nThis challenge is quite different from the other two. First, we look at the secret key initialisation:\nwith open(\u0026quot;/opt/flag/secret\u0026quot;, \u0026quot;rb\u0026quot;) as f: tp = Aes256GcmTP(f.read())  This means the secret key is the same over all connections.\nSecond, nonce initialisation:\n# this is the best way to avoid nonce reuse now = int(time()) if now \u0026lt;= self.last_timestamp: now = self.last_timestamp + 1 self.last_timestamp = now nonce = now.to_bytes(12, \u0026quot;big\u0026quot;)  This obviously can be bypassed using race condition.\nNow we have an GCM oracle that uses same secret key and same nonce for all queries. That means the encryption is a stream cipher with same key $\\Rightarrow$ we can forge ciphertext however we like.\nTo forge the authentication tag, we need to look more closely at the math. The tag is computed as follow:\n Compute $H = E(0^{128})$. Compute $pad = E(nonce | 0^{31} | 1)$. Call $c_1, c_2$ the two blocks of the ciphertext. The tag is: $c_1 \\cdot H^3 + c_2 \\cdot H^2 + (len(A) | len(C)) \\cdot H + pad$  Here we have $len(A) = 0, len(C) = 32 * 8 = 256$. All computation is on $GF(2^{128})$. This is a field, which means it has distributivity, a.k.a. $A(B+C) = AB + AC$. That means, consider 3 same-length ciphertext $c^1, c^2, c^3$, we have:\n$tag(c^1) + tag(c^2) + tag(c^3)$ $= (c^1_1 + c^2_1 + c^3_1) \\cdot H^3 + (c^1_2 + c^2_2 + c^3_2) \\cdot H_2 + (len(A) | len(C)) \\cdot H + pad$ $= tag(c^1 + c^2 + c^3) $\n(reminder that addition in $GF(2^n)$ is the XOR operation)\nDefine $et = E(target)$ (ciphertext for $target$). If we can forge these 3 values:\n c1 = et[:16] + 00 * 16 c2 = 00 * 16 + et[16:] c3 = 00 * 32  then we have $tag(c^1) + tag(c^2) + tag(c^3) = tag(c^1 + c^2 + c^3) = tag(E(target))$\nTo construct $c^1, c^2, c^3$ we do as follow:\n Define $p = random(32 bytes)$ Query $E(p)$. Compute $E(target) = E(p) \\oplus p \\oplus target$. Compute $p^1 = target \\oplus (E(target)[:16] | (00 * 16))$ Compute $p^2 = target \\oplus ((00 * 16) | E(target)[16:])$ Compute $p^3 = target \\oplus E(target)$  Then it\u0026rsquo;s easy to see that $E(p^i) = c^i$.\nRSA with Gaussian integers The string we submit is split into 2 halves, each converted to an integer, combined together into a Complex number. This complex number is then RSA-ed, concatenated, and returned to us.\nWe do not know $N$ and $e$.\nThe multiplication function is this:\ndef complex_mult(c1, c2, modulus): return Complex( (c1.re * c2.re - c1.im * c2.im) % modulus, # real part (c1.re * c2.im + c1.im * c2.re) % modulus, # image part )  We define $norm(a) = a.re^2 + a.im^2$.\nIt\u0026rsquo;s easy to see that $norm$ is multiplicative. In other word: $norm(c1 \\cdot c2) = norm(c1) \\cdot norm(c2)$. This means that we have:\n$norm(s)^e \\equiv norm(s^e) \\equiv norm(E(s))\\ (mod\\ N)$\nwhich is regular RSA.\nTo find $N$, we query 3 values: $E(2), E(4), E(8)$. We can see that:\n\\begin{equation} \\begin{aligned} E(2) \\cdot E(2) \u0026amp;\\equiv 2^e \\cdot 2^e \\\\\n\u0026amp;\\equiv 4^e \\\\\n\u0026amp;\\equiv E(4) \\pmod N \\\\\n\\Leftrightarrow E(2)^2 - E(4) \u0026amp;\\equiv 0\\ \\pmod N \\\\\n\\\\\nE(2) \\cdot E(2) \\cdot E(2) \u0026amp;\\equiv 2^e \\cdot 2^e \\cdot 2^e \\\\\n\u0026amp;\\equiv 8^e \\\\\n\u0026amp;\\equiv E(8) \\pmod N \\\\\n\\Leftrightarrow E(2)^3 - E(8) \u0026amp;\\equiv 0 \\pmod N \\end{aligned} \\end{equation}\nFrom that, we have:\n$$N \\mid GCD(E(2)^2 - E(4), E(2)^3 - E(8))$$\nDefine $g = GCD(E(2)^2 - E(4), E(2)^3 - E(8))$. By experiment, we can see that most prime factors of $g$ (except for $p, q$) is small (no greater than 1000). We now have $N$. Then I spent the next 12 hours struggling to compute $e$, only to realise that I don\u0026rsquo;t need it :(\nIt\u0026rsquo;s easy to see that:\n\\begin{equation} \\begin{aligned} E(2target) \u0026amp;\\equiv E(2) \\cdot E(target) \\pmod N \\\\\n\\Leftrightarrow E(target) \u0026amp;\\equiv E(2target) \\cdot E(2)^{-1} \\pmod N \\end{aligned} \\end{equation}\n$E(2)^{-1}\\ mod\\ N$ can be easily computed using extended Euclid alg (we already have $E(2)$ and $N$).\nDone.\n .medium-zoom-image { background-color: #fff; }  ","date":1610150400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1610150400,"objectID":"76f11bf6053de94cf6cc1c37a9f191cb","permalink":"https://lamnhh.github.io/post/2021-01-09-ascis2020-crypto/","publishdate":"2021-01-09T00:00:00Z","relpermalink":"/post/2021-01-09-ascis2020-crypto/","section":"post","summary":"This is me upsolving the challenges 1 month after the contest. All patches are unavailable to download, so all I discuss here is how to attack the original challenges (with no patches).","tags":["ascis","ascis2020","ctf","crypto"],"title":"ASCIS 2020 - Crypto writeups","type":"post"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8576ec274c98b3831668a172fa632d80","permalink":"https://lamnhh.github.io/about/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/about/","section":"","summary":"","tags":null,"title":"","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f26b5133c34eec1aa0a09390a36c2ade","permalink":"https://lamnhh.github.io/admin/config.yml","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/admin/config.yml","section":"","summary":"","tags":null,"title":"","type":"wowchemycms"}]